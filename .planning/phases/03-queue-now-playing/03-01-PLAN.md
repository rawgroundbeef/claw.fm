---
phase: 03-queue-now-playing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/shared/src/index.ts
  - api/src/lib/rotation.ts
  - api/src/lib/kv-cache.ts
  - api/wrangler.toml
autonomous: true

must_haves:
  truths:
    - "Decay weight formula produces higher values for newer tracks than older tracks"
    - "Tracks with higher tip_weight get proportionally higher selection weight"
    - "Weighted random selection picks tracks according to their computed weights"
    - "Anti-repeat filtering excludes recently played track IDs and wallets"
    - "Anti-repeat disabled when catalog size < 5 tracks (fallback to full catalog)"
    - "KV cache helpers can write, read, and delete now-playing state"
  artifacts:
    - path: "api/src/lib/rotation.ts"
      provides: "Exponential decay weighting and weighted random selection"
      exports: ["calculateDecayWeight", "selectTrackWeighted", "HALF_LIFE_DAYS", "DECAY_CONSTANT"]
    - path: "api/src/lib/kv-cache.ts"
      provides: "KV read/write/invalidate helpers for now-playing cache"
      exports: ["getCachedNowPlaying", "cacheNowPlaying", "invalidateNowPlaying"]
    - path: "packages/shared/src/index.ts"
      provides: "NowPlayingResponse, QueueResponse, NowPlayingTrack shared types"
      contains: "NowPlayingResponse"
    - path: "api/wrangler.toml"
      provides: "DO binding (QUEUE_BRAIN) and KV namespace (KV) configuration"
      contains: "QUEUE_BRAIN"
  key_links:
    - from: "api/src/lib/rotation.ts"
      to: "packages/shared/src/index.ts"
      via: "imports Track type for weight calculation"
      pattern: "import.*Track.*@claw/shared"
---

<objective>
Create the foundational pieces for Phase 3: decay-weighted rotation algorithm, KV cache helpers, shared API response types, and Cloudflare infrastructure bindings.

Purpose: These are independent building blocks that Plans 02 and 03 depend on. The rotation algorithm is the station's brain logic, the KV cache enables fast reads for thousands of listeners, the types define the API contract, and the wrangler config enables Durable Objects and KV.

Output: Four files ready for QueueBrain DO (Plan 02) and API routes (Plan 03) to consume.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-queue-now-playing/03-CONTEXT.md
@.planning/phases/03-queue-now-playing/03-RESEARCH.md
@packages/shared/src/index.ts
@api/wrangler.toml
@api/src/lib/audio.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Shared types, rotation algorithm, and KV cache helpers</name>
  <files>
    packages/shared/src/index.ts
    api/src/lib/rotation.ts
    api/src/lib/kv-cache.ts
  </files>
  <action>
**1. Update shared types** (`packages/shared/src/index.ts`):

Add these types (append to existing file, do NOT remove existing types):

```typescript
// Now-playing API response
export interface NowPlayingTrack {
  id: number
  title: string
  artistWallet: string
  artistName?: string
  duration: number   // seconds
  coverUrl?: string
  fileUrl: string
  genre: string
}

export interface NowPlayingResponse {
  state: 'playing' | 'waiting'
  track?: NowPlayingTrack
  startedAt?: number      // UNIX timestamp ms when track started
  endsAt?: number         // UNIX timestamp ms when track ends
  nextTrack?: NowPlayingTrack  // Included when < 10s remaining (crossfade pre-buffer)
  message?: string        // Present when state === 'waiting'
}

export interface QueueResponse {
  tracks: NowPlayingTrack[]    // Next 5 upcoming tracks
  currentlyPlaying?: NowPlayingTrack
}
```

**2. Create rotation algorithm** (`api/src/lib/rotation.ts`):

Implement exponential decay with weighted random selection:

- `HALF_LIFE_DAYS = 10` (gentle decay, configurable)
- `HALF_LIFE_MS = HALF_LIFE_DAYS * 24 * 60 * 60 * 1000`
- `DECAY_CONSTANT = Math.log(2) / HALF_LIFE_MS`
- `ANTI_REPEAT_THRESHOLD = 5` (disable anti-repeat below this catalog size)

Export `calculateDecayWeight(track: { created_at: number; tip_weight: number }, now: number): number`:
- Exponential decay: `weight = Math.exp(-DECAY_CONSTANT * (now - track.created_at))`
- Tip boost: `tipBoost = 1 + (track.tip_weight / 1e17)` (0.1 ETH = 2x weight)
- Return `weight * tipBoost`
- Minimum weight floor of `0.001` to prevent zero weights

Export `selectTrackWeighted(tracks: TrackCandidate[], recentTrackIds: Set<number>, recentWallets: Set<string>): TrackCandidate | null`:
- `TrackCandidate` interface: `{ id: number; created_at: number; tip_weight: number; wallet: string }`
- Filter out `recentTrackIds` and `recentWallets` (anti-repeat + artist diversity)
- If filtered list is empty AND original tracks.length >= ANTI_REPEAT_THRESHOLD, return null (genuinely no eligible tracks)
- If filtered list is empty AND original tracks.length < ANTI_REPEAT_THRESHOLD, use unfiltered tracks (small catalog fallback)
- Calculate weights for eligible candidates using `calculateDecayWeight`
- Build cumulative weights array
- Generate random number in [0, totalWeight)
- Binary search for selected track (O(log n))
- Return selected track

**3. Create KV cache helpers** (`api/src/lib/kv-cache.ts`):

Three helper functions for now-playing cache:

```typescript
import type { NowPlayingResponse } from '@claw/shared'

export async function getCachedNowPlaying(kv: KVNamespace): Promise<NowPlayingResponse | null> {
  const cached = await kv.get('now-playing', 'json')
  return cached as NowPlayingResponse | null
}

export async function cacheNowPlaying(kv: KVNamespace, response: NowPlayingResponse, endsAt?: number): Promise<void> {
  // Cache until track ends or max 60s, whichever is sooner
  // For 'waiting' state, cache for only 5 seconds (might get track soon)
  let ttl: number
  if (response.state === 'waiting') {
    ttl = 5
  } else if (endsAt) {
    const secondsRemaining = Math.floor((endsAt - Date.now()) / 1000)
    ttl = Math.max(1, Math.min(secondsRemaining, 60))
  } else {
    ttl = 60
  }
  await kv.put('now-playing', JSON.stringify(response), { expirationTtl: ttl })
}

export async function invalidateNowPlaying(kv: KVNamespace): Promise<void> {
  await kv.delete('now-playing')
}
```

Keep all KV-related caching logic here. The key is always `'now-playing'`.
  </action>
  <verify>
Run `pnpm --filter @claw/shared build` (or tsc) to verify shared types compile. Run `pnpm --filter claw-fm-api build` or `npx tsc --noEmit -p api/tsconfig.json` to verify rotation.ts and kv-cache.ts compile without errors. Verify rotation.ts exports calculateDecayWeight and selectTrackWeighted. Verify kv-cache.ts exports getCachedNowPlaying, cacheNowPlaying, invalidateNowPlaying.
  </verify>
  <done>
Shared types include NowPlayingResponse, QueueResponse, and NowPlayingTrack. Rotation algorithm computes decay weights and performs weighted random selection with anti-repeat logic. KV cache helpers handle read/write/invalidate for now-playing state. All files compile without TypeScript errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wrangler config for Durable Object and KV bindings</name>
  <files>
    api/wrangler.toml
  </files>
  <action>
Add Durable Object and KV namespace bindings to `api/wrangler.toml`:

**Add DO binding** (after existing bindings):
```toml
[[durable_objects.bindings]]
name = "QUEUE_BRAIN"
class_name = "QueueBrain"

[[migrations]]
tag = "v1"
new_classes = ["QueueBrain"]
```

**Add KV namespace** (after existing bindings):
```toml
[[kv_namespaces]]
binding = "KV"
id = "placeholder-dev"
preview_id = "placeholder-preview"
```

Note: The `id` values are placeholders for local development. For production, create real KV namespace with `wrangler kv namespace create KV` and update the id. During local dev with `wrangler dev`, KV works with any id value.

Do NOT modify existing D1, R2, or [vars] sections. Only append new bindings.

After updating wrangler.toml, verify the config is valid by running `wrangler dev --dry-run` or similar check. If wrangler complains about the KV id, that's expected for local dev (wrangler dev creates local KV automatically).
  </action>
  <verify>
Read api/wrangler.toml and confirm it contains: `QUEUE_BRAIN` DO binding with class_name `QueueBrain`, a `[[migrations]]` section with tag `v1` and `new_classes = ["QueueBrain"]`, and a `[[kv_namespaces]]` binding with name `KV`. Existing D1, R2, and [vars] sections remain unchanged.
  </verify>
  <done>
wrangler.toml has QUEUE_BRAIN Durable Object binding, KV namespace binding, and DO migration tag. All existing bindings preserved.
  </done>
</task>

</tasks>

<verification>
- `packages/shared/src/index.ts` exports NowPlayingResponse, QueueResponse, NowPlayingTrack types
- `api/src/lib/rotation.ts` exports calculateDecayWeight and selectTrackWeighted
- `api/src/lib/kv-cache.ts` exports getCachedNowPlaying, cacheNowPlaying, invalidateNowPlaying
- `api/wrangler.toml` contains DO binding QUEUE_BRAIN and KV namespace KV
- TypeScript compiles without errors across both packages
</verification>

<success_criteria>
All four files exist and compile. Rotation algorithm handles edge cases (empty tracks, small catalog, zero weights). KV helpers handle both playing and waiting states. Wrangler config includes all new bindings without breaking existing ones. Types define the API contract for now-playing and queue endpoints.
</success_criteria>

<output>
After completion, create `.planning/phases/03-queue-now-playing/03-01-SUMMARY.md`
</output>
