---
phase: 03-queue-now-playing
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - api/src/durable-objects/QueueBrain.ts
  - api/src/durable-objects/types.ts
autonomous: true

must_haves:
  truths:
    - "QueueBrain DO initializes SQLite tables on first run (queue_state, play_history)"
    - "getCurrentState returns current track info, start time, end time, and next track"
    - "alarm() handler advances queue: records play history, promotes next to current, selects new next, schedules alarm, invalidates KV"
    - "selectNextTrack queries D1 for all tracks, applies anti-repeat + artist diversity, uses weighted selection"
    - "startImmediately is idempotent -- if already playing, does nothing"
    - "Single-track catalog loops the same track (station never silent)"
    - "Anti-repeat disabled when catalog < 5 tracks"
    - "Pre-selected next track cached in DO SQLite state"
    - "KV invalidated on every track change"
    - "Alarm scheduled for exact track end time (millisecond precision)"
  artifacts:
    - path: "api/src/durable-objects/QueueBrain.ts"
      provides: "Durable Object managing queue state, track selection, alarm-based advancement"
      exports: ["QueueBrain"]
      min_lines: 150
    - path: "api/src/durable-objects/types.ts"
      provides: "DO-internal types for queue state and track candidates"
      exports: ["QueueState", "PlayHistoryEntry"]
  key_links:
    - from: "api/src/durable-objects/QueueBrain.ts"
      to: "api/src/lib/rotation.ts"
      via: "imports selectTrackWeighted and calculateDecayWeight"
      pattern: "import.*rotation"
    - from: "api/src/durable-objects/QueueBrain.ts"
      to: "D1 tracks table"
      via: "env.DB queries for track catalog"
      pattern: "env\\.DB\\.prepare"
    - from: "api/src/durable-objects/QueueBrain.ts"
      to: "KV namespace"
      via: "env.KV.delete for cache invalidation"
      pattern: "env\\.KV\\.delete"
    - from: "api/src/durable-objects/QueueBrain.ts"
      to: "DO Alarms API"
      via: "this.ctx.storage.setAlarm for precise track end scheduling"
      pattern: "setAlarm"
---

<objective>
Build the QueueBrain Durable Object -- the single source of truth for queue state, track selection, and automatic advancement.

Purpose: This is the station's scheduling brain. It decides what plays, when it ends, what comes next, and auto-advances using alarms. Everything else (API routes, KV cache) reads from this DO. Getting this right means the station runs itself once started.

Output: QueueBrain.ts Durable Object class with SQLite state, alarm-based advancement, weighted track selection, and idempotent immediate-start.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-queue-now-playing/03-CONTEXT.md
@.planning/phases/03-queue-now-playing/03-RESEARCH.md
@.planning/phases/03-queue-now-playing/03-01-SUMMARY.md
@api/src/lib/rotation.ts
@api/src/lib/kv-cache.ts
@packages/shared/src/index.ts
@api/wrangler.toml
@api/migrations/0001_tracks-schema.sql
@api/migrations/0002_submission-fields.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: DO types and QueueBrain Durable Object</name>
  <files>
    api/src/durable-objects/types.ts
    api/src/durable-objects/QueueBrain.ts
  </files>
  <action>
**1. Create DO types** (`api/src/durable-objects/types.ts`):

```typescript
export interface QueueState {
  currentTrackId: number | null
  currentStartedAt: number | null   // UNIX ms
  currentEndsAt: number | null      // UNIX ms
  nextTrackId: number | null
}

export interface PlayHistoryEntry {
  trackId: number
  playedAt: number  // UNIX ms
}

export interface TrackRow {
  id: number
  title: string
  wallet: string
  artist_name: string | null
  duration: number         // seconds (from D1)
  file_url: string
  cover_url: string | null
  genre: string
  created_at: number       // UNIX seconds (from D1 unixepoch())
  tip_weight: number
}
```

**2. Create QueueBrain DO** (`api/src/durable-objects/QueueBrain.ts`):

This is the core of the station. Use the modern DurableObject base class pattern (extending `DurableObject`).

**Env type** (define at top of file):
```typescript
interface Env {
  DB: D1Database
  KV: KVNamespace
  QUEUE_BRAIN: DurableObjectNamespace
  AUDIO_BUCKET: R2Bucket
  PLATFORM_WALLET: string
}
```

**Constructor:**
- Extends `DurableObject`
- Call `super(ctx, env)` (modern DO pattern)
- In `ctx.blockConcurrencyWhile()`, initialize SQLite tables:
  - `queue_state`: key TEXT PRIMARY KEY, value TEXT NOT NULL
  - `play_history`: id INTEGER PRIMARY KEY AUTOINCREMENT, track_id INTEGER NOT NULL, played_at INTEGER NOT NULL
  - Index: `idx_ph_played_at` on play_history(played_at DESC)

**Public methods (called via RPC from routes):**

`async getCurrentState(): Promise<QueueState>`:
- Read current_track_id, current_started_at, current_ends_at, next_track_id from queue_state table
- Return structured QueueState object
- If no rows, return all nulls (empty state)

`async getNextTrackId(): Promise<number | null>`:
- Read next_track_id from queue_state
- Return null if not set

`async startImmediately(trackId: number): Promise<boolean>`:
- **Must be idempotent** -- check if already playing (current_track_id exists and alarm is active)
- If already playing, return false (no-op)
- Fetch track from D1 by id to get duration
- Set current_track_id = trackId, current_started_at = Date.now(), current_ends_at = Date.now() + (duration * 1000)
- Pre-select next track (call internal selectNext method)
- Schedule alarm for current_ends_at: `this.ctx.storage.setAlarm(endsAt)`
- Invalidate KV cache: `this.env.KV.delete('now-playing')`
- Return true (started)

`async getQueuePreview(depth: number = 5): Promise<number[]>`:
- Simulate selecting next N tracks (probabilistic preview)
- Get recent history for anti-repeat context
- For each slot: call weighted selection excluding previously selected IDs in this preview
- Return array of track IDs
- If not enough tracks to fill depth, return what we have

**Private methods:**

`private async selectNext(): Promise<number | null>`:
- Fetch ALL tracks from D1: `SELECT id, created_at, tip_weight, wallet FROM tracks`
- Get recently played track IDs (last 10 from play_history)
- Get recently played wallets (last 3 distinct wallets from play_history)
- Call `selectTrackWeighted(tracks, recentTrackIds, recentWallets)` from rotation.ts
- **Important:** D1 stores created_at as UNIX seconds (from `unixepoch()`). Convert to milliseconds before passing to decay function: `created_at * 1000`
- If only 1 track exists and it's the current track, return that same track (single-track loop)
- Store selected next_track_id in queue_state
- Return the selected track ID or null if no tracks exist

`private async setState(key: string, value: string): Promise<void>`:
- `INSERT OR REPLACE INTO queue_state (key, value) VALUES (?, ?)`

`private async getState(key: string): Promise<string | null>`:
- `SELECT value FROM queue_state WHERE key = ?`

`private async recordPlay(trackId: number): Promise<void>`:
- `INSERT INTO play_history (track_id, played_at) VALUES (?, ?)`
- Prune old history: `DELETE FROM play_history WHERE played_at < ?` (keep last 24 hours)

`private async getRecentTrackIds(limit: number = 10): Promise<Set<number>>`:
- `SELECT DISTINCT track_id FROM play_history ORDER BY played_at DESC LIMIT ?`
- Return as Set

`private async getRecentWallets(limit: number = 3): Promise<Set<string>>`:
- Join play_history with D1 tracks table? **No -- D1 is external.** Instead, store wallet alongside track_id in play_history.
- **Alternative approach:** Add a `wallet` column to play_history table, populate it when recording plays. Then: `SELECT DISTINCT wallet FROM play_history ORDER BY played_at DESC LIMIT ?`
- Update play_history schema to: `track_id INTEGER NOT NULL, wallet TEXT NOT NULL, played_at INTEGER NOT NULL`
- Update recordPlay to also store wallet

**alarm() handler:**
- This fires when the current track's duration elapses
- Wrap in try/catch for robustness (alarm retries up to 6 times)
- Record current track in play_history (call recordPlay)
- Read next_track_id from state
- If next_track_id exists:
  - Fetch track details from D1 (need duration)
  - Set as current (update current_track_id, started_at, ends_at)
  - Select new next track
  - Schedule alarm for new ends_at
  - Invalidate KV
- If next_track_id is null (edge case, no tracks?):
  - Fetch all tracks from D1
  - If tracks exist, pick one (weighted selection) and start it
  - If no tracks at all, clear current state, invalidate KV (station goes to waiting state)

**Key design points:**
- ALL state persisted to SQLite (never rely on class properties for critical state)
- D1 is the catalog (tracks), DO SQLite is the queue brain's working memory
- created_at in D1 is UNIX seconds, Date.now() is UNIX milliseconds -- be careful with conversion
- Use `this.ctx.storage.sql.exec(query, ...params)` for DO SQLite operations
- KV invalidation must happen on EVERY state change (track start, advance, stop)
- The DO class must be exported from index.ts (Plan 03 handles this, but the class itself must use `export class QueueBrain extends DurableObject`)
  </action>
  <verify>
Run TypeScript compilation to verify QueueBrain.ts compiles without errors. Verify the file exports `QueueBrain` class extending `DurableObject`. Check that it imports from `../lib/rotation` for weighted selection. Verify SQLite schema includes queue_state and play_history tables. Verify alarm() handler exists and calls advance logic. Verify startImmediately checks for existing playback (idempotent).
  </verify>
  <done>
QueueBrain DO class exists with SQLite state management, alarm-based advancement, weighted track selection via rotation.ts, anti-repeat history tracking, idempotent startImmediately, queue preview generation, and KV cache invalidation. All state persisted to DO SQLite. Single-track looping handled. TypeScript compiles clean.
  </done>
</task>

</tasks>

<verification>
- QueueBrain.ts is a proper Durable Object (extends DurableObject, has alarm() handler)
- SQLite tables created in blockConcurrencyWhile (queue_state, play_history)
- getCurrentState returns current track ID, start time, end time, next track ID
- alarm() records play, advances to next track, selects new next, schedules new alarm, invalidates KV
- startImmediately is idempotent (no-op if already playing)
- selectNext uses rotation.ts weighted selection with anti-repeat
- getQueuePreview returns up to N track IDs
- TypeScript compiles without errors
</verification>

<success_criteria>
QueueBrain DO fully implements queue state management, automatic advancement via alarms, weighted track selection with anti-repeat and artist diversity, single-track looping, idempotent immediate start, queue preview, and KV cache invalidation. All critical state persisted to SQLite, not class properties.
</success_criteria>

<output>
After completion, create `.planning/phases/03-queue-now-playing/03-02-SUMMARY.md`
</output>
