---
phase: 03-queue-now-playing
plan: 03
type: execute
wave: 3
depends_on: ["03-01", "03-02"]
files_modified:
  - api/src/routes/now-playing.ts
  - api/src/routes/queue.ts
  - api/src/routes/submit.ts
  - api/src/index.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/now-playing returns NowPlayingResponse with state 'playing' or 'waiting'"
    - "GET /api/now-playing serves from KV cache when available (fast path)"
    - "GET /api/now-playing falls back to QueueBrain DO on cache miss"
    - "GET /api/now-playing includes nextTrack when < 10s remaining (crossfade pre-buffer)"
    - "GET /api/queue returns QueueResponse with up to 5 upcoming tracks"
    - "Empty queue returns state 'waiting' with message 'Waiting for first track'"
    - "POST /api/submit triggers immediate start when first track is submitted"
    - "QueueBrain class is exported from api entry point for Cloudflare to discover"
    - "All new routes mounted in Hono app"
    - "Bindings type includes QUEUE_BRAIN and KV"
  artifacts:
    - path: "api/src/routes/now-playing.ts"
      provides: "GET /api/now-playing endpoint with KV cache + DO fallback"
      exports: ["default (Hono route)"]
    - path: "api/src/routes/queue.ts"
      provides: "GET /api/queue endpoint returning upcoming tracks"
      exports: ["default (Hono route)"]
    - path: "api/src/routes/submit.ts"
      provides: "Updated submit route with immediate-start trigger for first track"
      contains: "QUEUE_BRAIN"
    - path: "api/src/index.ts"
      provides: "Hono app with all routes mounted, QueueBrain DO exported"
      contains: "export { QueueBrain }"
  key_links:
    - from: "api/src/routes/now-playing.ts"
      to: "api/src/lib/kv-cache.ts"
      via: "getCachedNowPlaying for fast reads"
      pattern: "getCachedNowPlaying"
    - from: "api/src/routes/now-playing.ts"
      to: "api/src/durable-objects/QueueBrain.ts"
      via: "DO stub.getCurrentState() on cache miss"
      pattern: "QUEUE_BRAIN.*get.*getCurrentState"
    - from: "api/src/routes/queue.ts"
      to: "api/src/durable-objects/QueueBrain.ts"
      via: "DO stub.getQueuePreview() for upcoming tracks"
      pattern: "QUEUE_BRAIN.*get.*getQueuePreview"
    - from: "api/src/routes/submit.ts"
      to: "api/src/durable-objects/QueueBrain.ts"
      via: "DO stub.startImmediately() when first track submitted"
      pattern: "startImmediately"
    - from: "api/src/index.ts"
      to: "api/src/durable-objects/QueueBrain.ts"
      via: "re-export for Cloudflare DO discovery"
      pattern: "export.*QueueBrain"
---

<objective>
Wire everything together: create now-playing and queue API routes, modify submit to trigger immediate start, and update index.ts to mount routes and export the QueueBrain DO.

Purpose: This plan connects the brain (QueueBrain) to the outside world. After this, the station has working read APIs that serve cached now-playing state and queue previews, and the submit endpoint bootstraps playback when the first track arrives.

Output: Working GET /api/now-playing, GET /api/queue, updated POST /api/submit, and properly wired index.ts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-queue-now-playing/03-CONTEXT.md
@.planning/phases/03-queue-now-playing/03-RESEARCH.md
@.planning/phases/03-queue-now-playing/03-01-SUMMARY.md
@.planning/phases/03-queue-now-playing/03-02-SUMMARY.md
@api/src/index.ts
@api/src/routes/submit.ts
@api/src/durable-objects/QueueBrain.ts
@api/src/lib/kv-cache.ts
@packages/shared/src/index.ts
@api/wrangler.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Now-playing and queue API routes</name>
  <files>
    api/src/routes/now-playing.ts
    api/src/routes/queue.ts
  </files>
  <action>
**1. Create GET /api/now-playing route** (`api/src/routes/now-playing.ts`):

Create a Hono sub-route matching the pattern of existing routes (genres.ts, submit.ts).

The Env/Bindings type must include: `DB: D1Database`, `AUDIO_BUCKET: R2Bucket`, `PLATFORM_WALLET: string`, `QUEUE_BRAIN: DurableObjectNamespace`, `KV: KVNamespace`.

**Handler logic:**

Step 1: Try KV cache first (fast path):
- Call `getCachedNowPlaying(c.env.KV)`
- If cached response exists, return it immediately as JSON

Step 2: Cache miss -- query QueueBrain DO:
- Get DO stub: `c.env.QUEUE_BRAIN.idFromName('global-queue')` then `.get(id)`
- Call `stub.getCurrentState()` to get QueueState (currentTrackId, startedAt, endsAt, nextTrackId)

Step 3: If no current track (state is empty/null):
- Build waiting response: `{ state: 'waiting', message: 'Waiting for first track' }`
- Cache with short TTL via `cacheNowPlaying(kv, response)` (5s TTL for waiting state)
- Return JSON

Step 4: Current track exists -- fetch full metadata from D1:
- `SELECT id, title, wallet, artist_name, duration, file_url, cover_url, genre FROM tracks WHERE id = ?`
- Build NowPlayingTrack from D1 row (map snake_case DB columns to camelCase type fields)

Step 5: Check if next track should be included (crossfade pre-buffer):
- If `endsAt - Date.now() < 10000` (less than 10s remaining) AND nextTrackId exists:
  - Fetch next track metadata from D1
  - Include as `nextTrack` in response

Step 6: Build playing response:
```typescript
const response: NowPlayingResponse = {
  state: 'playing',
  track: { id, title, artistWallet: wallet, artistName: artist_name, duration, coverUrl: cover_url, fileUrl: file_url, genre },
  startedAt: state.currentStartedAt,
  endsAt: state.currentEndsAt,
  nextTrack: nextTrackData || undefined
}
```

Step 7: Cache and return:
- `cacheNowPlaying(kv, response, state.currentEndsAt)`
- Return JSON response

**2. Create GET /api/queue route** (`api/src/routes/queue.ts`):

Handler logic:

Step 1: Get DO stub (same pattern as now-playing)

Step 2: Call `stub.getQueuePreview(5)` to get array of track IDs

Step 3: If empty array, return `{ tracks: [], currentlyPlaying: undefined }`

Step 4: For each track ID, fetch metadata from D1:
- Build a single query: `SELECT id, title, wallet, artist_name, duration, file_url, cover_url, genre FROM tracks WHERE id IN (?, ?, ?, ?, ?)`
- Map results to NowPlayingTrack objects
- **Preserve the order from getQueuePreview** (D1 query doesn't guarantee order, so map by ID after query)

Step 5: Optionally include currentlyPlaying:
- Get current state from DO
- If playing, fetch current track metadata and include

Step 6: Return QueueResponse JSON

**Design notes:**
- Do NOT cache queue responses in KV (probabilistic preview changes each time, caching would freeze the preview)
- Queue route can be slightly slower (hits DO directly) -- it's called less frequently than now-playing
- Map D1 column names (snake_case) to TypeScript interface fields (camelCase) consistently
  </action>
  <verify>
Run TypeScript compilation to verify both route files compile. Verify now-playing.ts imports from kv-cache.ts and uses getCachedNowPlaying/cacheNowPlaying. Verify queue.ts calls getQueuePreview on DO stub. Check both routes return proper typed responses (NowPlayingResponse, QueueResponse).
  </verify>
  <done>
GET /api/now-playing returns cached NowPlayingResponse (KV fast path) with DO fallback, includes nextTrack for crossfade pre-buffer when < 10s remaining, handles empty queue with 'waiting' state. GET /api/queue returns QueueResponse with up to 5 upcoming tracks from probabilistic preview. Both compile clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Submit integration and index.ts wiring</name>
  <files>
    api/src/routes/submit.ts
    api/src/index.ts
  </files>
  <action>
**1. Update submit route** (`api/src/routes/submit.ts`):

Add immediate-start trigger after track is successfully persisted to D1.

Update the Env type to include `QUEUE_BRAIN: DurableObjectNamespace` and `KV: KVNamespace`.

After Step 9 (queue position calculation), before Step 10 (return response), add:

```typescript
// Step 9.5: Trigger immediate start if this is the first track
// Check if this is the only track in the system
if (queuePosition === 1) {
  try {
    const queueId = c.env.QUEUE_BRAIN.idFromName('global-queue')
    const queueStub = c.env.QUEUE_BRAIN.get(queueId)
    await queueStub.startImmediately(trackId)
  } catch (err) {
    // Don't fail the submission if queue start fails
    // The track is already saved -- queue will pick it up on next cycle
    console.error('Failed to trigger immediate start:', err)
  }
}
```

**Important:** The `queuePosition === 1` check uses the existing COUNT query result. This is a simple heuristic: if there's exactly 1 track total, this must be the first. The QueueBrain.startImmediately is idempotent, so even if a race condition triggers it twice, it won't cause problems.

Do NOT change any other logic in submit.ts. Only add the immediate-start block and update the Env type.

**2. Update index.ts** (`api/src/index.ts`):

Three changes:

a) **Add DO and KV to Bindings type:**
```typescript
type Bindings = {
  DB: D1Database
  AUDIO_BUCKET: R2Bucket
  PLATFORM_WALLET: string
  QUEUE_BRAIN: DurableObjectNamespace
  KV: KVNamespace
}
```

b) **Import and mount new routes:**
```typescript
import nowPlayingRoute from './routes/now-playing'
import queueRoute from './routes/queue'

// After existing route mounts:
app.route('/api/now-playing', nowPlayingRoute)
app.route('/api/queue', queueRoute)
```

c) **Re-export QueueBrain DO class** (Cloudflare requires DO classes exported from entry point):
```typescript
export { QueueBrain } from './durable-objects/QueueBrain'
```

Place the export AFTER the `export default app` statement. Cloudflare discovers DO classes from the entry point's exports.

**Final index.ts structure should be:**
```
imports...
type Bindings...
const app = new Hono<{ Bindings }>()
middleware...
routes...
export default app
export { QueueBrain } from './durable-objects/QueueBrain'
```

After all changes, run `wrangler dev` to verify:
- Health endpoint still works: `curl http://localhost:8787/health`
- Now-playing returns waiting state: `curl http://localhost:8787/api/now-playing`
- Queue returns empty: `curl http://localhost:8787/api/queue`
- Genres still works: `curl http://localhost:8787/api/genres`
  </action>
  <verify>
Run TypeScript compilation to verify all files compile. Start dev server with `wrangler dev` (or `pnpm --filter claw-fm-api dev`). Test endpoints:
- `curl http://localhost:8787/health` returns 200 with status ok
- `curl http://localhost:8787/api/now-playing` returns JSON with state 'waiting'
- `curl http://localhost:8787/api/queue` returns JSON with empty tracks array
- `curl http://localhost:8787/api/genres` returns 200 with genre list
Verify QueueBrain is exported from index.ts. Verify submit.ts has QUEUE_BRAIN in its Env type.
  </verify>
  <done>
All routes mounted: /api/now-playing, /api/queue alongside existing /api/submit and /api/genres. QueueBrain DO exported from entry point for Cloudflare discovery. Submit route triggers immediate start on first track. Dev server starts without errors. Empty queue returns 'waiting' state. All existing endpoints still functional.
  </done>
</task>

</tasks>

<verification>
- GET /api/now-playing returns `{ state: 'waiting', message: 'Waiting for first track' }` when no tracks exist
- GET /api/queue returns `{ tracks: [] }` when no tracks exist
- GET /health still returns 200
- GET /api/genres still returns genre list
- POST /api/submit still works (unchanged validation/payment flow)
- QueueBrain class exported from api/src/index.ts
- wrangler dev starts without binding or compilation errors
- TypeScript compiles clean across all modified files
</verification>

<success_criteria>
Complete Phase 3 feature set working: now-playing endpoint with KV caching and DO fallback, queue endpoint with probabilistic preview, submit route with immediate-start trigger, all wired through index.ts. Station returns 'waiting' when empty and will auto-start on first submission. When tracks exist and alarm fires, queue auto-advances, selects next track using decay-weighted rotation, and invalidates KV cache.
</success_criteria>

<output>
After completion, create `.planning/phases/03-queue-now-playing/03-03-SUMMARY.md`
</output>
