---
phase: 09-frontend-profiles
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - web/package.json
  - web/src/main.tsx
  - web/src/App.tsx
  - web/src/contexts/AudioContext.tsx
  - web/src/pages/RadioPage.tsx
  - web/src/layouts/RadioLayout.tsx
  - web/public/_redirects
autonomous: true

must_haves:
  truths:
    - "Audio continues playing without interruption when URL changes"
    - "PlayerBar remains mounted and visible at all times regardless of route"
    - "The radio view renders at the root URL path exactly as it did before routing was added"
    - "Direct URL access to any path serves the SPA index.html"
  artifacts:
    - path: "web/src/contexts/AudioContext.tsx"
      provides: "Audio state provider wrapping crossfade, volume, muted, recovery, server time"
      exports: ["AudioProvider", "useAudio"]
    - path: "web/src/pages/RadioPage.tsx"
      provides: "Radio view extracted from App.tsx main content"
      min_lines: 80
    - path: "web/src/layouts/RadioLayout.tsx"
      provides: "Shared layout with Header, PlayerBar, Outlet"
      min_lines: 30
    - path: "web/src/App.tsx"
      provides: "BrowserRouter with AudioProvider wrapping Routes"
      contains: "BrowserRouter"
    - path: "web/public/_redirects"
      provides: "SPA fallback for Cloudflare Pages"
      contains: "/* /index.html 200"
  key_links:
    - from: "web/src/App.tsx"
      to: "web/src/contexts/AudioContext.tsx"
      via: "AudioProvider wraps BrowserRouter"
      pattern: "AudioProvider"
    - from: "web/src/layouts/RadioLayout.tsx"
      to: "web/src/components/Player/PlayerBar.tsx"
      via: "PlayerBar rendered as sibling to Outlet"
      pattern: "PlayerBar.*Outlet|Outlet.*PlayerBar"
    - from: "web/src/main.tsx"
      to: "web/src/App.tsx"
      via: "WalletProvider wraps App"
      pattern: "WalletProvider"
---

<objective>
Install React Router v7, lift audio state above the router, and refactor the monolithic App.tsx into a routed architecture with persistent player bar.

Purpose: This is the highest-risk change in v1.1 -- the architectural foundation that ensures audio never stops during navigation. Every subsequent plan depends on this working correctly.

Output: A routed app where the radio view renders at `/`, PlayerBar stays mounted across all routes, and audio state (crossfade, volume, recovery) lives above the router in a React Context.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-frontend-profiles/09-CONTEXT.md
@.planning/phases/09-frontend-profiles/09-RESEARCH.md
@web/src/App.tsx
@web/src/main.tsx
@web/src/hooks/useCrossfade.ts
@web/src/hooks/useNowPlaying.ts
@web/src/hooks/useRecovery.ts
@web/src/hooks/useServerTime.ts
@web/src/contexts/WalletContext.tsx
@web/src/components/Player/PlayerBar.tsx
@web/src/components/Player/NowPlaying.tsx
@web/src/lib/constants.ts
@web/package.json
@web/vite.config.ts
@packages/shared/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install React Router v7 and create AudioContext provider</name>
  <files>
    web/package.json
    web/src/contexts/AudioContext.tsx
  </files>
  <action>
    1. Install react-router v7:
       ```
       cd web && npm install react-router@7
       ```

    2. Create `web/src/contexts/AudioContext.tsx` that provides ALL audio-related state to the component tree:
       - Call `useNowPlaying()` (polling state from API)
       - Call `useCrossfade()` (dual audio player engine) -- NOTE: useCrossfade internally calls useNowPlaying and useServerTime already. The context must NOT double-call useNowPlaying. Instead, expose the crossfade return AND the nowPlaying return from a single useCrossfade call. Looking at useCrossfade.ts, it calls useNowPlaying internally but does NOT expose the nowPlaying return. The cleanest approach: call useNowPlaying() once in the context, and pass its return value to useCrossfade... BUT useCrossfade calls useNowPlaying internally and can't accept it as a prop.

       IMPORTANT ARCHITECTURAL DECISION: useCrossfade already calls useNowPlaying internally. Do NOT create a separate useNowPlaying call. Instead, the AudioContext should:
       - Call `useCrossfade()` which internally manages nowPlaying state
       - Call `useServerTime()` for server offset (needed by recovery)
       - Manage volume state (useState for volume and muted)
       - Manage recovery via `useRecovery()`
       - Manage confetti state

       The problem: useCrossfade exposes `currentTrack` but NOT the full nowPlaying return (state, nextTrack, startedAt, endsAt, etc.). The RadioPage needs `nowPlaying.state`, `nowPlaying.track`, `nowPlaying.nextTrack` for its conditional rendering. Currently App.tsx calls BOTH useNowPlaying() and useCrossfade() -- and useCrossfade internally calls useNowPlaying() again (two separate polling instances).

       Resolution: Keep the same pattern as current App.tsx -- call both useNowPlaying() and useCrossfade() in the AudioContext provider. This works because useNowPlaying is a polling hook with independent state -- two instances polling the same endpoint is harmless (both get the same cached KV data). The alternative of refactoring useCrossfade to accept nowPlaying as a parameter would require changing the hook signature and is out of scope.

       AudioContext provider shape:
       ```typescript
       interface AudioContextValue {
         // From useNowPlaying
         nowPlaying: UseNowPlayingReturn
         // From useCrossfade
         crossfade: UseCrossfadeReturn
         // Volume state
         volume: number
         muted: boolean
         handleVolumeChange: (v: number) => void
         handleMuteToggle: () => void
         // Recovery
         recovery: { isReconnecting: boolean; isOffline: boolean }
         // Theme
         theme: 'dark' | 'light'
         toggleTheme: () => void
         // Confetti
         showConfetti: boolean
         triggerConfetti: () => void
         // Modal
         modalOpen: boolean
         openModal: () => void
         dismissModal: () => void
       }
       ```

       Use `useMemo` to memoize the context value object to prevent unnecessary re-renders (per research pitfall #3). Group the stable references (functions) separately from changing values.

       Export `AudioProvider` component and `useAudio()` hook (throws if used outside provider, same pattern as WalletContext).

       NOTE: The useRecovery hook needs access to crossfade.isPlaying, nowPlaying.track, nowPlaying.startedAt, serverOffset, and crossfade references -- all of which are available in the provider. Move the full recovery setup (including the onReconnect and onVisibilityRestore callbacks) from App.tsx into the provider.
  </action>
  <verify>
    `cd web && npx tsc --noEmit` passes with no errors.
    `cat web/package.json | grep react-router` shows react-router v7.x in dependencies.
    `cat web/src/contexts/AudioContext.tsx` exports AudioProvider and useAudio.
  </verify>
  <done>
    react-router@7 is installed. AudioContext.tsx exists with AudioProvider component and useAudio hook that provides crossfade, nowPlaying, volume, recovery, theme, and modal state. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor App.tsx into routed architecture with RadioLayout and RadioPage</name>
  <files>
    web/src/App.tsx
    web/src/pages/RadioPage.tsx
    web/src/layouts/RadioLayout.tsx
    web/src/main.tsx
    web/public/_redirects
  </files>
  <action>
    1. Create `web/src/pages/RadioPage.tsx`:
       - Extract the main content area from App.tsx (everything inside `<main>`) into this component.
       - This includes: empty state, live indicator, cover art, track info with artist name, action buttons (tip/buy), large play button, up next display.
       - Import `useAudio()` from AudioContext to access crossfade, nowPlaying, volume, etc.
       - The `displayArtist` logic stays here (deriving display name from crossfade.currentTrack).
       - Keep the existing artist name display as a `<p>` tag for now (Plan 03 will convert it to a Link).

    2. Create `web/src/layouts/RadioLayout.tsx`:
       - Contains the shared layout structure: Header + main content area (Outlet) + PlayerBar.
       - Import `useAudio()` for the data needed by Header (theme toggle, modal open) and PlayerBar (crossfade, nowPlaying, volume).
       - Header content: logo, "What is this?" button, WalletButton, theme toggle -- all extracted from current App.tsx.
       - The `<Outlet />` component from react-router renders the active route's page component.
       - PlayerBar renders BELOW the Outlet as a sibling -- it never unmounts during navigation.
       - Include `<Toaster>` and `<ConfettiCelebration>` and `<ReconnectingIndicator>` and `<WhatIsThisModal>` in the layout since they're global UI.
       - Structure:
         ```tsx
         <div className="min-h-screen flex flex-col" style={{ background: 'var(--bg-primary)' }}>
           <Toaster ... />
           <ConfettiCelebration ... />
           <ReconnectingIndicator ... />
           <header>...</header>
           <main className="flex-1 flex flex-col items-center justify-center px-4">
             <Outlet />
           </main>
           <PlayerBar ... />
           <WhatIsThisModal ... />
         </div>
         ```

    3. Refactor `web/src/App.tsx`:
       - Replace the entire current content with the router setup.
       - Wrap with AudioProvider (INSIDE WalletProvider which is in main.tsx).
       - Use BrowserRouter from react-router with Routes and Route.
       - Route structure:
         ```tsx
         <AudioProvider>
           <BrowserRouter>
             <Routes>
               <Route element={<RadioLayout />}>
                 <Route index element={<RadioPage />} />
                 {/* Profile routes will be added in Plan 02 */}
                 <Route path="*" element={<RadioPage />} />  {/* Temporary catch-all */}
               </Route>
             </Routes>
           </BrowserRouter>
         </AudioProvider>
         ```
       - The temporary catch-all `path="*"` ensures the app doesn't break on unknown routes until Plan 02 adds the real 404 page.
       - App.tsx should be dramatically simpler (~20-30 lines) since all logic moved to AudioContext, RadioLayout, and RadioPage.

    4. Update `web/src/main.tsx`:
       - No changes needed -- WalletProvider already wraps App, and AudioProvider is inside App.tsx.

    5. Create `web/public/_redirects`:
       - Cloudflare Pages SPA fallback. Without this, direct URL access to /artist/foo returns 404 from the CDN.
       - Content: `/* /index.html 200`
       - This tells CF Pages to serve index.html for all paths, letting React Router handle routing client-side.
       - IMPORTANT: The existing Vite dev server proxy handles /api, /health, /audio paths. The _redirects file is for production CF Pages only and doesn't affect dev.

    CRITICAL: Do NOT change any imports in useNowPlaying.ts, useCrossfade.ts, useAudioPlayer.ts, or useRecovery.ts. These hooks remain untouched. Only their CALL SITE moves from App.tsx to AudioContext.tsx.

    CRITICAL: The `<main>` tag structure in RadioLayout must match the current App.tsx structure exactly (`flex-1 flex flex-col items-center justify-center px-4`) so RadioPage content renders identically.
  </action>
  <verify>
    `cd web && npx tsc --noEmit` passes with no errors.
    `cd web && npm run build` produces a successful build with no warnings about missing modules.
    `ls web/public/_redirects` confirms the SPA fallback file exists.
    The built output in `web/dist/` contains the _redirects file (Vite copies public/ to dist/).
  </verify>
  <done>
    App.tsx is a thin router wrapper (~20-30 lines). RadioLayout.tsx contains the persistent header + player bar + Outlet. RadioPage.tsx contains the radio view main content. SPA fallback exists for CF Pages. The app builds successfully and the radio view renders at `/` with all existing functionality preserved (cover art, track info, play button, tips, volume, theme toggle).
  </done>
</task>

</tasks>

<verification>
- `cd web && npm run build` succeeds
- `cd web && npx tsc --noEmit` passes
- The app structure matches: main.tsx -> WalletProvider -> App (AudioProvider -> BrowserRouter -> Routes -> RadioLayout -> RadioPage)
- PlayerBar is rendered in RadioLayout outside of Outlet
- AudioContext.tsx provides crossfade, nowPlaying, volume, recovery, theme to all route components
- web/public/_redirects contains SPA fallback rule
</verification>

<success_criteria>
1. react-router@7 is installed and the app builds without errors
2. Audio state (crossfade hooks, AudioContext singleton, gain nodes) lives above BrowserRouter in AudioProvider
3. PlayerBar renders in RadioLayout as sibling to Outlet -- it will never unmount during navigation
4. RadioPage renders the exact same radio UI at `/` as the pre-router App.tsx did
5. SPA fallback file exists for Cloudflare Pages production deployment
</success_criteria>

<output>
After completion, create `.planning/phases/09-frontend-profiles/09-01-SUMMARY.md`
</output>
