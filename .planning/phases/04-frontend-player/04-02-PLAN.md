---
phase: 04-frontend-player
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - web/src/hooks/useAudioPlayer.ts
  - web/src/hooks/useCrossfade.ts
  - web/src/hooks/useNowPlaying.ts
autonomous: true

must_haves:
  truths:
    - "Audio plays from R2 URL through Web Audio API graph when play() is called"
    - "Crossfade smoothly transitions between two tracks over 2 seconds"
    - "Next track pre-loads when < 10s remaining on current track"
    - "Now-playing state is polled and tracks transition automatically"
  artifacts:
    - path: "web/src/hooks/useAudioPlayer.ts"
      provides: "Core audio playback with Web Audio API graph (source -> gain -> analyser -> destination)"
      exports: ["useAudioPlayer"]
    - path: "web/src/hooks/useCrossfade.ts"
      provides: "Track crossfade logic with equal-power curves and preload"
      exports: ["useCrossfade"]
    - path: "web/src/hooks/useNowPlaying.ts"
      provides: "Now-playing state polling and track transition management"
      exports: ["useNowPlaying"]
  key_links:
    - from: "web/src/hooks/useAudioPlayer.ts"
      to: "web/src/utils/audioContext.ts"
      via: "import getAudioContext, resumeAudioContext"
      pattern: "import.*getAudioContext.*from.*audioContext"
    - from: "web/src/hooks/useCrossfade.ts"
      to: "web/src/utils/audioContext.ts"
      via: "import getAudioContext for scheduling"
      pattern: "import.*getAudioContext.*from.*audioContext"
    - from: "web/src/hooks/useNowPlaying.ts"
      to: "/api/now-playing"
      via: "fetch polling for track state"
      pattern: "fetch.*api/now-playing"
---

<objective>
Build the core audio playback engine: hooks that manage the Web Audio API graph, crossfade between tracks, and poll now-playing state to drive automatic track transitions.

Purpose: This is the heart of the player. After this plan, calling `play()` produces audio, tracks crossfade smoothly, and the player automatically advances when the server rotates tracks. All downstream UI components consume these hooks.

Output: 3 new hook files that provide the complete audio engine
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-frontend-player/04-RESEARCH.md
@.planning/phases/04-frontend-player/04-CONTEXT.md
@.planning/phases/04-frontend-player/04-01-SUMMARY.md

@packages/shared/src/index.ts -- NowPlayingResponse, NowPlayingTrack types
@web/src/utils/audioContext.ts -- getAudioContext(), resumeAudioContext()
@web/src/utils/equalPowerCurve.ts -- calculateEqualPowerGains()
@web/src/utils/timeSync.ts -- calculateServerOffset(), getCorrectPlaybackPosition()
</context>

<tasks>

<task type="auto">
  <name>Task 1: useAudioPlayer and useNowPlaying hooks</name>
  <files>
    web/src/hooks/useAudioPlayer.ts
    web/src/hooks/useNowPlaying.ts
  </files>
  <action>
**useAudioPlayer.ts** - Core audio graph and playback control:

Creates and manages a Web Audio API graph for a single audio source. This hook is used twice by the crossfade system (current track + next track).

Interface:
```typescript
interface UseAudioPlayerReturn {
  play: () => Promise<void>;
  pause: () => void;
  setSource: (url: string) => void;
  setVolume: (volume: number) => void;  // 0-1
  isPlaying: boolean;
  isLoaded: boolean;    // readyState >= 3 (HAVE_FUTURE_DATA)
  isLoading: boolean;   // loading but not yet playable
  currentTime: number;  // current playback position in seconds
  audioElement: HTMLAudioElement | null;
  gainNode: GainNode | null;
  analyserNode: AnalyserNode | null;
}
```

Implementation:
- On mount: create `new Audio()` element with `crossOrigin = 'anonymous'` (required for CORS + Web Audio). Create audio graph: `ctx.createMediaElementSource(audio)` -> `GainNode` -> `AnalyserNode` -> `ctx.destination`. Store refs for all nodes.
- `setSource(url)`: Set `audio.src = url`. Listen for `canplaythrough` event to set `isLoaded = true`. Listen for `loadstart` to set `isLoading = true`. Listen for `error` to log and set error state.
- `play()`: Call `resumeAudioContext()` first (autoplay policy), then `audio.play()`. Set `isPlaying = true`.
- `pause()`: Call `audio.pause()`. Set `isPlaying = false`.
- `setVolume(v)`: Set `gainNode.gain.value = v` (direct set is fine for user volume, not crossfade).
- Track `currentTime` via `timeupdate` event on audio element.
- AnalyserNode config: `fftSize = 2048`, `smoothingTimeConstant = 0.8`.
- Cleanup on unmount: `audio.pause()`, `audio.src = ''`, disconnect nodes.
- IMPORTANT: Only create MediaElementSource ONCE per audio element. A MediaElementSource can only be created once for a given HTMLAudioElement. Store in ref, do not recreate.

**useNowPlaying.ts** - Now-playing state polling:

Polls `/api/now-playing` and manages track state transitions.

Interface:
```typescript
interface UseNowPlayingReturn {
  state: 'waiting' | 'playing' | 'loading';
  track: NowPlayingTrack | null;
  nextTrack: NowPlayingTrack | null;
  startedAt: number | null;
  endsAt: number | null;
  message: string | null;      // "Waiting for first track" when state === 'waiting'
  timeRemaining: number | null; // seconds until track ends
  error: string | null;
}
```

Implementation:
- Poll `/api/now-playing` every 5 seconds (matching KV cache TTL for waiting state).
- When response `state === 'playing'`: extract track, startedAt, endsAt, nextTrack. Calculate `timeRemaining` on each render (using `Date.now()` and `endsAt`).
- When response `state === 'waiting'`: set track to null, show message.
- Track transition detection: when `track.id` changes, the track has rotated. Emit this change so crossfade can trigger. Use `useRef` to compare previous track ID.
- When `timeRemaining < 10`: poll more frequently (every 2 seconds) to catch the `nextTrack` field appearing.
- Handle fetch errors: keep last known state, set error message. Retry on next interval.
- Use `useEffect` with `setInterval` for polling. Use `useCallback` for the fetch function.
  </action>
  <verify>
Run `cd /Users/rawgroundbeef/Projects/claw.fm && pnpm --filter claw-fm-web exec tsc --noEmit` -- no type errors. Verify both files export their hooks with correct return types.
  </verify>
  <done>useAudioPlayer creates complete Web Audio API graph with play/pause/volume control. useNowPlaying polls server state and detects track transitions. Both compile without errors.</done>
</task>

<task type="auto">
  <name>Task 2: useCrossfade hook for track transitions</name>
  <files>web/src/hooks/useCrossfade.ts</files>
  <action>
**useCrossfade.ts** - Manages two audio players for seamless track transitions:

This is the orchestrator hook that uses two `useAudioPlayer` instances (A and B) and crossfades between them when tracks change.

Interface:
```typescript
interface UseCrossfadeReturn {
  play: () => Promise<void>;
  pause: () => void;
  setVolume: (volume: number) => void;
  isPlaying: boolean;
  isLoading: boolean;
  currentTrack: NowPlayingTrack | null;
  activeAnalyser: AnalyserNode | null;  // For visualizer to consume
  currentTime: number;        // Current playback position in seconds
  duration: number;           // Current track duration in seconds
}
```

Implementation:
- Internally manages two `useAudioPlayer` instances: playerA and playerB. Uses a ref `activePlayer: 'A' | 'B'` to track which is currently playing.
- Takes `useNowPlaying` state as input (track, nextTrack, startedAt, endsAt, serverOffset from useServerTime).
- **Initial play**: When user presses play for the first time, load current track URL into active player, seek to correct position (using `getCorrectPlaybackPosition`), and start playback.
- **Preloading**: When `nextTrack` appears in now-playing response (< 10s remaining), load it into the inactive player. Set the inactive player's source to `nextTrack.fileUrl`. Wait for `isLoaded` to become true.
- **Crossfade trigger**: When `track.id` changes (detected via useNowPlaying), start the crossfade:
  1. Call `cancelScheduledValues(now)` on both gain nodes (prevent conflicts with previous automation).
  2. Set active player gain: `setValueAtTime(currentGain, now)`, then `linearRampToValueAtTime(0, now + 2)`.
  3. Set inactive player gain: `setValueAtTime(0, now)`, then `linearRampToValueAtTime(userVolume, now + 2)`.
  4. Start playback on inactive player (seek to correct position first).
  5. Swap `activePlayer` ref.
  6. After crossfade completes (2s timeout), pause and reset the now-inactive player.
- **Volume**: `setVolume` updates a `userVolume` ref and applies to the active player's gain node. During crossfade, the target gain is `userVolume` (not 1.0).
- **Crossfade duration**: 2 seconds (from CONTEXT.md: "Short & subtle crossfade (~2 seconds)").
- `activeAnalyser`: Returns the analyser node of whichever player is currently active. Updates after crossfade swap.
- `currentTime` and `duration`: From the active player's audio element.

IMPORTANT: Do NOT use `calculateEqualPowerGains` for the scheduled ramp -- `linearRampToValueAtTime` is sufficient for a 2-second crossfade (per research: "linearRamp is acceptable for short (2s) crossfades"). If audible artifacts, upgrade to `setValueCurveAtTime` with cosine array later.
  </action>
  <verify>
Run `cd /Users/rawgroundbeef/Projects/claw.fm && pnpm --filter claw-fm-web exec tsc --noEmit` -- no type errors. Verify useCrossfade exports the hook and uses both useAudioPlayer internally.
  </verify>
  <done>useCrossfade orchestrates two audio players, handles preloading next track, executes 2-second crossfade transitions, and exposes active analyser node for visualization. Compiles without errors.</done>
</task>

</tasks>

<verification>
- `pnpm --filter claw-fm-web exec tsc --noEmit` passes
- Files exist: `web/src/hooks/useAudioPlayer.ts`, `web/src/hooks/useCrossfade.ts`, `web/src/hooks/useNowPlaying.ts`
- useAudioPlayer creates MediaElementSource -> GainNode -> AnalyserNode -> destination graph
- useCrossfade manages two players and schedules gain ramps for crossfade
- useNowPlaying polls /api/now-playing and detects track ID changes
</verification>

<success_criteria>
The complete audio engine exists: audio graph with gain and analysis, server state polling with transition detection, and dual-player crossfade orchestration. All hooks compile and are ready for UI integration.
</success_criteria>

<output>
After completion, create `.planning/phases/04-frontend-player/04-02-SUMMARY.md`
</output>
