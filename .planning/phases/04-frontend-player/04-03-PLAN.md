---
phase: 04-frontend-player
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - web/src/hooks/useVisualizer.ts
  - web/src/components/Visualizer/Waveform.tsx
  - web/src/components/Visualizer/IdleAnimation.tsx
autonomous: true

must_haves:
  truths:
    - "Waveform line animates in response to live audio frequency data when playing"
    - "Gentle idle animation plays when audio is paused"
    - "Canvas renders crisp on HiDPI/Retina displays"
    - "Visualization runs at 60fps without dropped frames"
  artifacts:
    - path: "web/src/hooks/useVisualizer.ts"
      provides: "Hook connecting AnalyserNode to canvas drawing loop"
      exports: ["useVisualizer"]
    - path: "web/src/components/Visualizer/Waveform.tsx"
      provides: "Canvas-based waveform component"
      exports: ["Waveform"]
    - path: "web/src/components/Visualizer/IdleAnimation.tsx"
      provides: "Gentle breathing animation for paused state"
      exports: ["IdleAnimation"]
  key_links:
    - from: "web/src/hooks/useVisualizer.ts"
      to: "AnalyserNode"
      via: "getByteTimeDomainData for waveform data"
      pattern: "getByteTimeDomainData"
    - from: "web/src/components/Visualizer/Waveform.tsx"
      to: "web/src/hooks/useVisualizer.ts"
      via: "hook provides drawing function"
      pattern: "useVisualizer"
---

<objective>
Build the waveform visualizer that responds to live audio and shows a gentle idle animation when paused.

Purpose: The visualizer is the primary visual element of the main page -- a smooth oscillating waveform line that makes claw.fm feel alive. It uses the AnalyserNode from the audio engine to read frequency data and renders via Canvas 2D.

Output: 1 hook + 2 components for the complete visualization system
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-frontend-player/04-RESEARCH.md
@.planning/phases/04-frontend-player/04-CONTEXT.md
@.planning/phases/04-frontend-player/04-01-SUMMARY.md

@web/tailwind.config.js -- brand color 'electric': '#0066FF'
</context>

<tasks>

<task type="auto">
  <name>Task 1: useVisualizer hook and Waveform canvas component</name>
  <files>
    web/src/hooks/useVisualizer.ts
    web/src/components/Visualizer/Waveform.tsx
  </files>
  <action>
**useVisualizer.ts** - Hook that drives the waveform animation loop:

Interface:
```typescript
interface UseVisualizerProps {
  analyserNode: AnalyserNode | null;
  canvasRef: React.RefObject<HTMLCanvasElement>;
  isPlaying: boolean;
  color?: string;  // defaults to '#0066FF' (electric brand color)
}
```

Implementation:
- When `analyserNode` and `canvasRef.current` both exist, start the animation loop.
- Create `Uint8Array(analyserNode.frequencyBinCount)` for data buffer. Store in ref (create once, reuse).
- Animation loop with `requestAnimationFrame`:
  - If `isPlaying`: call `analyserNode.getByteTimeDomainData(dataArray)` to get live waveform data.
  - If not playing: use the idle animation data instead (flat line with gentle sine wave perturbation -- see IdleAnimation task).
  - Handle HiDPI: `canvas.width = rect.width * devicePixelRatio`, `canvas.height = rect.height * devicePixelRatio`, `ctx.scale(dpr, dpr)`. Do this ONCE on mount and on resize, NOT every frame.
  - Clear canvas with transparent background (so page background shows through).
  - Draw smooth waveform line: iterate over dataArray, normalize each value (v = dataArray[i] / 128.0), calculate y = (v * height) / 2. Use `ctx.lineTo()` to draw the path. Stroke with the brand color.
  - Line style: `lineWidth = 2`, `strokeStyle = color`, `lineCap = 'round'`, `lineJoin = 'round'` for smooth appearance.
- Store `requestAnimationFrame` ID in ref, cancel on cleanup.
- Handle window resize: add `ResizeObserver` on the canvas element to recalculate HiDPI dimensions when size changes. Clean up observer on unmount.
- Return `{ isActive: boolean }` (true when animation loop is running).

**Waveform.tsx** - Canvas wrapper component:

Props:
```typescript
interface WaveformProps {
  analyserNode: AnalyserNode | null;
  isPlaying: boolean;
  className?: string;
}
```

Implementation:
- Renders a `<canvas>` element with `ref={canvasRef}`.
- Calls `useVisualizer({ analyserNode, canvasRef, isPlaying })`.
- Canvas should fill its container: `style={{ width: '100%', height: '100%' }}` and className for Tailwind sizing.
- The component is purely a canvas wrapper -- all drawing logic lives in the hook.
- Default className includes the canvas sizing. Parent controls actual dimensions.
  </action>
  <verify>
Run `cd /Users/rawgroundbeef/Projects/claw.fm && pnpm --filter claw-fm-web exec tsc --noEmit` -- no type errors. Verify Waveform component renders a canvas and uses useVisualizer hook.
  </verify>
  <done>useVisualizer hook manages Canvas animation loop with HiDPI support and brand-colored waveform. Waveform component wraps canvas and connects hook. Both compile without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Idle animation for paused state</name>
  <files>web/src/components/Visualizer/IdleAnimation.tsx</files>
  <action>
**IdleAnimation.tsx** - Gentle breathing/drift animation when audio is paused:

From CONTEXT.md: "Gentle idle animation when paused -- subtle breathing/drift so the page feels alive."

This is NOT a separate canvas -- it modifies the Waveform behavior. The approach: when `isPlaying` is false, the useVisualizer hook generates synthetic waveform data that creates a subtle sine wave "breathing" effect.

Refactor approach: Instead of a separate component, create an exported utility function that generates idle waveform data:

```typescript
// IdleAnimation.tsx (exports helper, not a React component)
export function generateIdleWaveform(
  dataArray: Uint8Array,
  bufferLength: number,
  time: number  // monotonic time for animation
): void
```

Implementation:
- Fill `dataArray` with values that create a gentle sine wave pattern.
- Use `time` (from `performance.now() / 1000`) to animate the wave slowly.
- Base value: 128 (center line in Uint8Array 0-255 range).
- Add: `amplitude * Math.sin(frequency * i / bufferLength + phase)` where:
  - `amplitude = 3 + 2 * Math.sin(time * 0.5)` -- breathing effect (amplitude oscillates gently between 1 and 5)
  - `frequency = 2 * Math.PI * 2` -- two full sine waves across the width
  - `phase = time * 0.3` -- slow drift so the wave moves laterally
- Result: a very subtle, slowly breathing and drifting sine wave in the brand color. Almost flat, just enough movement to feel alive.

Update useVisualizer: When `isPlaying` is false, instead of calling `getByteTimeDomainData`, call `generateIdleWaveform(dataArray, bufferLength, performance.now() / 1000)`. The rest of the draw logic stays the same -- it just renders different data.

So the actual file exports `generateIdleWaveform` and useVisualizer imports it. The "component" is really a utility that plugs into the existing visualization pipeline.
  </action>
  <verify>
Run `cd /Users/rawgroundbeef/Projects/claw.fm && pnpm --filter claw-fm-web exec tsc --noEmit` -- no type errors. Verify IdleAnimation exports generateIdleWaveform and useVisualizer imports it for the paused state.
  </verify>
  <done>Idle animation generates subtle breathing sine wave data when paused. useVisualizer uses it as fallback when isPlaying is false. Canvas always shows either live audio waveform or gentle idle animation -- never a dead flat line.</done>
</task>

</tasks>

<verification>
- `pnpm --filter claw-fm-web exec tsc --noEmit` passes
- Files exist: `web/src/hooks/useVisualizer.ts`, `web/src/components/Visualizer/Waveform.tsx`, `web/src/components/Visualizer/IdleAnimation.tsx`
- Waveform component renders canvas with HiDPI support
- useVisualizer switches between live audio data and idle animation based on isPlaying
- Brand color '#0066FF' used for waveform stroke
</verification>

<success_criteria>
Complete visualization system: live waveform responds to audio when playing, gentle breathing animation when paused, crisp rendering on all screen densities. Ready to be placed in the main page layout.
</success_criteria>

<output>
After completion, create `.planning/phases/04-frontend-player/04-03-SUMMARY.md`
</output>
