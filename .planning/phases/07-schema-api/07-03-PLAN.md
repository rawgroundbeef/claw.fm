---
phase: 07-schema-api
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - api/src/routes/username.ts
  - api/src/routes/artist.ts
autonomous: true

must_haves:
  truths:
    - "Agent can check username availability via GET /api/username/:username/available without payment"
    - "Agent can look up a public profile by username via GET /api/artist/:username and receive profile with track catalog"
    - "GET /api/artist/:username returns 404 for non-existent usernames"
    - "Agent can look up a profile by wallet address via GET /api/artist/by-wallet/:wallet"
    - "GET /api/artist/by-wallet/:wallet returns 404 for wallets without profiles"
    - "Username availability check validates format and reserved words before querying DB"
  artifacts:
    - path: "api/src/routes/username.ts"
      provides: "GET /api/username/:username/available endpoint"
      min_lines: 30
    - path: "api/src/routes/artist.ts"
      provides: "GET /api/artist/:username and GET /api/artist/by-wallet/:wallet endpoints"
      min_lines: 60
  key_links:
    - from: "api/src/routes/username.ts"
      to: "packages/shared/src/index.ts"
      via: "Zod schema for username format validation"
      pattern: "import.*UsernameSchema.*@claw/shared"
    - from: "api/src/routes/artist.ts"
      to: "artist_profiles table"
      via: "SELECT query for profile data"
      pattern: "SELECT.*FROM artist_profiles"
    - from: "api/src/routes/artist.ts"
      to: "tracks table"
      via: "SELECT query for artist track catalog"
      pattern: "SELECT.*FROM tracks.*WHERE wallet"
---

<objective>
Implement the three public read endpoints: username availability check, artist profile lookup by username (with track catalog), and artist profile lookup by wallet address. These are free (no x402 payment required).

Purpose: These endpoints support profile discovery and the pre-creation availability check workflow. Agents check username availability before paying for profile creation. Listeners and other agents can look up artist profiles by username or wallet address.

Output: Three fully functional GET endpoints for profile reads and username checking.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-schema-api/07-CONTEXT.md
@.planning/phases/07-schema-api/07-RESEARCH.md
@.planning/phases/07-schema-api/07-01-SUMMARY.md
@packages/shared/src/index.ts
@api/src/routes/now-playing.ts
@api/src/lib/identicon.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement GET /api/username/:username/available</name>
  <files>api/src/routes/username.ts</files>
  <action>
Replace the 501 stub in `api/src/routes/username.ts` with the availability check endpoint.

**Env type** -- include DB binding only (no payment, no R2 needed).

**GET /:username/available handler** flow:

1. **Extract username** from route param: `c.req.param('username')`.

2. **Validate format** -- Import `UsernameSchema` from `@claw/shared`. Run `UsernameSchema.safeParse(username)`. If invalid, return 200 with `{ username, available: false, reason: 'Invalid username format' }`. Note: We return 200 (not 400) because "is this username available?" has a definitive answer -- "no, because the format is invalid." The response shape matches `UsernameAvailableResponse` plus an optional `reason` field.

   Actually, looking at the shared types, `UsernameAvailableResponse` is `{ username: string, available: boolean }`. Let's stick to that shape but add a `reason` field for developer experience:
   ```typescript
   { username: string, available: boolean, reason?: string }
   ```

3. **Query database** -- `SELECT id FROM artist_profiles WHERE username = ? COLLATE NOCASE` bound to the username param. The COLLATE NOCASE on the column means the query inherits it, but being explicit doesn't hurt.

4. **Return result**:
   - If row exists: `{ username, available: false }`
   - If no row: `{ username, available: true }`

**Import:** `UsernameSchema`, `UsernameAvailableResponse` from `@claw/shared`.

**Error handling:** Wrap in try/catch. On error, return 500 with `{ error: 'INTERNAL_ERROR', message: '...' }`.

This endpoint requires NO authentication and NO payment. It's a free public check.
  </action>
  <verify>
TypeScript compilation: `npx tsc --noEmit -p api/tsconfig.json`. Manual test with wrangler dev:
1. `curl http://localhost:8787/api/username/admin/available` should return `{ "username": "admin", "available": false, "reason": "..." }` (reserved word caught by Zod refine)
2. `curl http://localhost:8787/api/username/ab/available` should return `{ "username": "ab", "available": false, "reason": "..." }` (too short)
3. `curl http://localhost:8787/api/username/validname/available` should return `{ "username": "validname", "available": true }` (assuming no profile exists)
  </verify>
  <done>
GET /api/username/:username/available validates username format using shared Zod schema, checks database for existing claims (case-insensitive), and returns availability status. No payment required. Reserved words correctly blocked.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement GET /api/artist/:username and GET /api/artist/by-wallet/:wallet</name>
  <files>api/src/routes/artist.ts</files>
  <action>
Replace the 501 stub in `api/src/routes/artist.ts` with both artist lookup endpoints.

**Env type** -- include DB binding.

**GET /:username handler** flow:

1. **Extract username** from route param: `c.req.param('username')`.

2. **Query profile** -- `SELECT wallet, username, display_name, bio, avatar_url, created_at FROM artist_profiles WHERE username = ? COLLATE NOCASE`. Bind the username param.

3. **Handle not found** -- If no row, return 404: `{ error: 'NOT_FOUND', message: 'Artist not found' }`.

4. **Query track catalog** -- `SELECT id, title, wallet, artist_name, duration, file_url, cover_url, genre, description, tags, created_at, play_count, tip_weight FROM tracks WHERE wallet = ? ORDER BY created_at DESC`. Bind the profile's wallet address. This returns ALL tracks by the artist, sorted newest first.

   NOTE: For now, return all tracks. Pagination can be added later if catalogs grow large. The CONTEXT.md says Claude's discretion on separate paginated endpoint vs inline -- inline is simpler and sufficient for v1.

5. **Map to response types** -- Build `ArtistProfileWithTracks` response:
   ```typescript
   {
     profile: {
       username: row.username,
       displayName: row.display_name,
       bio: row.bio || null,
       avatarUrl: row.avatar_url ? `/audio/${row.avatar_url}` : null,
       wallet: row.wallet,
       createdAt: row.created_at
     },
     tracks: trackRows.map(t => ({
       id: t.id,
       title: t.title,
       wallet: t.wallet,
       duration: t.duration,
       fileUrl: `/audio/${t.file_url}`,
       coverUrl: t.cover_url ? (t.cover_url.startsWith('data:') ? t.cover_url : `/audio/${t.cover_url}`) : null,
       genre: t.genre,
       description: t.description || undefined,
       tags: t.tags || undefined,
       fileHash: '',  // Don't expose in public API
       artistName: t.artist_name || undefined,
       createdAt: t.created_at,
       playCount: t.play_count,
       tipWeight: t.tip_weight
     }))
   }
   ```

   IMPORTANT: Avatar URL and file URLs need the `/audio/` prefix for the audio streaming route (same pattern as now-playing.ts). Cover URLs that start with `data:` are identicon data URIs -- pass through as-is. Cover URLs that are R2 keys need the `/audio/` prefix.

6. **Return 200** with the `ArtistProfileWithTracks` response.

**GET /by-wallet/:wallet handler** flow:

1. **Extract wallet** from route param: `c.req.param('wallet')`.

2. **Basic validation** -- Check it looks like an Ethereum address: starts with `0x` and is 42 chars. If invalid format, return 400: `{ error: 'INVALID_WALLET', message: 'Invalid wallet address format' }`.

3. **Query profile** -- `SELECT wallet, username, display_name, bio, avatar_url, created_at FROM artist_profiles WHERE wallet = ?`. Bind the wallet param. Note: wallet is case-sensitive (stored as-is from x402 payment). For robustness, consider `WHERE LOWER(wallet) = LOWER(?)` or normalize to lowercase. Actually, Ethereum addresses are hex and case in the checksum matters. The wallet stored in the profile comes from the x402 payment `settleResult.payer`, which returns the checksummed address. For lookup, use exact match -- the caller should use the same checksummed format.

   SIMPLER: Use case-insensitive comparison since Ethereum addresses are hex: `WHERE wallet = ? COLLATE NOCASE`. This handles both checksummed and lowercase wallet addresses.

4. **Handle not found** -- If no row, return 404: `{ error: 'NOT_FOUND', message: 'No profile found for this wallet' }`.

5. **Return profile** -- Map to `ArtistPublicProfile` shape (same mapping as step 5 above, without tracks). Return 200.

   The response shape for by-wallet lookup: `{ profile: ArtistPublicProfile }`. This matches `ProfileResponse` from shared types (which wraps `ArtistProfile`). Actually `ProfileResponse` uses `ArtistProfile` (with id and updatedAt) and the by-wallet endpoint should return `ArtistPublicProfile` (without id/updatedAt). Use: `{ profile: ArtistPublicProfile }`.

**Imports:** `ArtistPublicProfile`, `ArtistProfileWithTracks`, `Track` from `@claw/shared`.

**Error handling:** Wrap each handler in try/catch. On error, return 500 with `{ error: 'INTERNAL_ERROR', message: '...' }`.

Both endpoints require NO authentication and NO payment. They are free public reads.

**IMPORTANT routing note:** The route for `/by-wallet/:wallet` must be registered BEFORE `/:username` in the Hono router, otherwise `/by-wallet/0x123...` would match `/:username` with username = "by-wallet". In Hono, more specific routes should come first. Register as:
```typescript
artistRoute.get('/by-wallet/:wallet', ...)
artistRoute.get('/:username', ...)
```
  </action>
  <verify>
TypeScript compilation: `npx tsc --noEmit -p api/tsconfig.json`. Manual test with wrangler dev (after running migration and creating a test profile):
1. `curl http://localhost:8787/api/artist/nonexistent` should return 404
2. `curl http://localhost:8787/api/artist/by-wallet/0x0000000000000000000000000000000000000000` should return 404
3. If a profile exists: `curl http://localhost:8787/api/artist/{username}` should return profile with tracks array
4. If a profile exists: `curl http://localhost:8787/api/artist/by-wallet/{wallet}` should return profile
  </verify>
  <done>
GET /api/artist/:username returns public profile with track catalog (sorted newest-first) or 404. GET /api/artist/by-wallet/:wallet returns public profile or 404. Both are free public endpoints with no authentication. Route ordering prevents path conflicts between /by-wallet/:wallet and /:username.
  </done>
</task>

</tasks>

<verification>
1. GET /api/username/:username/available returns correct availability for valid, invalid, and reserved usernames
2. GET /api/artist/:username returns profile with tracks for existing artists
3. GET /api/artist/:username returns 404 for non-existent usernames
4. GET /api/artist/by-wallet/:wallet returns profile for existing wallets
5. GET /api/artist/by-wallet/:wallet returns 404 for wallets without profiles
6. Route ordering: /by-wallet/:wallet doesn't conflict with /:username
7. TypeScript compiles without errors
</verification>

<success_criteria>
- Username availability check validates format (Zod), checks reserved words, and queries DB (case-insensitive)
- Artist lookup by username returns full profile with track catalog sorted newest-first
- Artist lookup by wallet returns profile data
- Both return proper 404 for missing resources
- No payment required for any read endpoint
- Response types match shared package interfaces
</success_criteria>

<output>
After completion, create `.planning/phases/07-schema-api/07-03-SUMMARY.md`
</output>
