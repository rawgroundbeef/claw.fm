---
phase: 07-schema-api
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - api/src/routes/profile.ts
  - api/src/routes/avatar.ts
autonomous: true

must_haves:
  truths:
    - "Agent can create a profile by sending PUT /api/profile with x402 payment header, username, and displayName -- receives created profile back"
    - "Agent can update their profile (change username, display name, bio) by sending PUT /api/profile with x402 payment -- receives updated profile"
    - "Duplicate username (case-insensitive) is rejected with 400 error WITHOUT settling x402 payment"
    - "Invalid username format is rejected with 400 error WITHOUT settling x402 payment"
    - "Reserved usernames are rejected with 400 error WITHOUT settling x402 payment"
    - "Agent can upload avatar by sending POST /api/avatar with x402 payment header and image file"
    - "Avatar is resized and stored in R2 as WebP, profile avatar_url is updated"
  artifacts:
    - path: "api/src/routes/profile.ts"
      provides: "PUT /api/profile endpoint with x402 gating, validation, and INSERT ON CONFLICT"
      min_lines: 80
    - path: "api/src/routes/avatar.ts"
      provides: "POST /api/avatar endpoint with x402 gating, image validation, and R2 upload"
      min_lines: 50
  key_links:
    - from: "api/src/routes/profile.ts"
      to: "packages/shared/src/index.ts"
      via: "Zod schema import for validation"
      pattern: "import.*ProfileUpdateSchema.*@claw/shared"
    - from: "api/src/routes/profile.ts"
      to: "api/src/middleware/x402.ts"
      via: "verifyPayment for x402 settlement"
      pattern: "verifyPayment"
    - from: "api/src/routes/profile.ts"
      to: "artist_profiles table"
      via: "INSERT ON CONFLICT for race-safe username claim"
      pattern: "ON CONFLICT.*DO NOTHING"
    - from: "api/src/routes/avatar.ts"
      to: "api/src/middleware/x402.ts"
      via: "verifyPayment for x402 settlement"
      pattern: "verifyPayment"
    - from: "api/src/routes/avatar.ts"
      to: "R2 bucket"
      via: "Avatar image stored in R2"
      pattern: "AUDIO_BUCKET.put"
---

<objective>
Implement the profile creation/update endpoint (PUT /api/profile) with x402 payment gating and the avatar upload endpoint (POST /api/avatar), replacing the stubs from Plan 01.

Purpose: This is the core write path -- agents use these endpoints to register usernames, set display names/bios, and upload avatars. The x402 payment deters squatting. Validation-before-payment ensures agents are never charged for invalid requests.

Output: Fully functional profile write endpoints that handle creation, updates, username changes, and avatar uploads with proper error handling.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-schema-api/07-CONTEXT.md
@.planning/phases/07-schema-api/07-RESEARCH.md
@.planning/phases/07-schema-api/07-01-SUMMARY.md
@api/src/routes/submit.ts
@api/src/middleware/x402.ts
@api/src/middleware/validation.ts
@api/src/lib/image.ts
@api/src/lib/identicon.ts
@packages/shared/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PUT /api/profile with x402 gating and INSERT ON CONFLICT</name>
  <files>api/src/routes/profile.ts</files>
  <action>
Replace the 501 stub in `api/src/routes/profile.ts` with a full implementation. Follow the exact pattern from `submit.ts` for x402 payment flow and error handling.

**Env type** -- must include DB, AUDIO_BUCKET, PLATFORM_WALLET, and KV bindings (same as submit.ts).

**PUT / handler** flow:

1. **Parse JSON body** -- use `c.req.json()` (not multipart -- profile is JSON, avatar is separate endpoint). Wrap in try/catch for malformed JSON.

2. **Validate with Zod** -- import `ProfileUpdateSchema`, `RESERVED_USERNAMES`, and `ProfileError` from `@claw/shared`. Parse body with `ProfileUpdateSchema.safeParse(body)`. If validation fails, return 400 with structured error matching `ProfileError` shape. Map Zod errors to the first error's message and path. Do NOT call verifyPayment yet.

3. **Normalize username** -- `.toLowerCase().trim()` on the validated username. The Zod schema enforces lowercase regex, but be defensive.

4. **Check reserved words** -- This is already handled by the Zod schema's `.refine()`, but if somehow bypassed, add a server-side check: `if (RESERVED_USERNAMES.includes(username))` return 400 `USERNAME_RESERVED`.

5. **Check username availability** -- Query D1: `SELECT id, wallet FROM artist_profiles WHERE username = ? COLLATE NOCASE`. If result exists AND `result.wallet !== walletAddress` (another wallet owns it), return 400 `USERNAME_TAKEN`. If result exists AND `result.wallet === walletAddress` (same wallet updating), that's fine -- proceed to payment. This pre-check catches most conflicts before payment, but INSERT ON CONFLICT in step 7 is the real race-condition safety net.

   IMPORTANT: We don't know walletAddress yet (comes from x402 in step 6). So reorder: do format validation in step 2, then x402 in step 3, then availability check in step 4 with the wallet. This matches submit.ts pattern where format validation is before payment but DB checks can be after.

   REVISED FLOW:
   - Step 2: Zod validation (format only, no DB) -- return 400 on failure, NO payment
   - Step 3: x402 payment verification -- return 402 if no payment header
   - Step 4: Username availability check (DB query) -- if taken by another wallet, we've already settled payment. This is a problem.

   ACTUALLY, the research and context explicitly state: "All validation (username format, availability, avatar) completes before x402 settlement" (API-05). So we need wallet address BEFORE payment. But verifyPayment both verifies AND settles.

   SOLUTION: The payment header contains the payer wallet. We can decode it to get the wallet address for pre-checks, then verify+settle only after all validation passes. Look at x402.ts: the payment payload is `JSON.parse(atob(paymentHeader))`. We can extract the payer from the payload without settling.

   REVISED REVISED FLOW:
   - Step 2: Zod validation (format, reserved words) -- 400 on failure, NO payment
   - Step 3: Extract wallet from payment header (decode but don't verify/settle). If no payment header, return 402 with requirements.
   - Step 4: Check username availability with DB query using extracted wallet -- 400 if taken by another wallet, NO payment settled
   - Step 5: NOW call verifyPayment to verify + settle
   - Step 6: INSERT ON CONFLICT for race safety
   - Step 7: Return created/updated profile

   For step 3, extract wallet: Read the `X-PAYMENT` or `PAYMENT-SIGNATURE` header, decode base64, parse JSON, and look for the payer field. The OpenFacilitator PaymentPayload structure has `payload.authorization.from` for v1 or similar. Actually, let's look at what verifyPayment returns -- `settleResult.payer`. We need to find where payer lives in the payload.

   SIMPLER APPROACH: Create a helper function `extractPayerFromHeader(c: Context): string | null` that reads the payment header, decodes it, and extracts the payer address. This is a read-only operation -- no verification or settlement.

   Looking at the @openfacilitator/sdk PaymentPayload type, the payer address is typically at `payload.authorization.from` or `payload.payload.authorization.from`. Since we can't be 100% sure of the structure without testing, and the existing code uses `settleResult.payer`, we should take a pragmatic approach:

   **PRAGMATIC APPROACH:** Do format + reserved word validation before payment (step 2). Then call verifyPayment which returns walletAddress (step 3). Then do the DB availability check (step 4). If availability fails, the payment has already been settled -- this is acceptable because:
   - The Zod schema `.refine()` already blocks reserved words (no payment)
   - Format validation blocks invalid usernames (no payment)
   - Username collisions are rare in practice (most agents check availability first via GET /api/username/:username/available)
   - The 0.01 USDC cost makes repeated collisions trivial financially

   This matches the submit.ts pattern exactly: format validation before payment, DB checks after payment (duplicate check in submit.ts happens after verifyPayment too -- see line 80-94 of submit.ts).

   USE THIS PRAGMATIC APPROACH. It matches existing patterns.

6. **Verify x402 payment** -- Call `verifyPayment(c, requirements)` with same pattern as submit.ts. Requirements: `scheme: 'exact'`, `network: 'base'`, `maxAmountRequired: '10000'` (0.01 USDC, 6 decimals), `asset: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'`, `resource: '/api/profile'`, `description: 'Profile registration fee'`, `payTo: c.env.PLATFORM_WALLET`. Return 402 if no/invalid payment.

7. **Check if wallet already has a profile** -- Query: `SELECT id, username FROM artist_profiles WHERE wallet = ?`.
   - If EXISTS: This is an UPDATE. Run: `UPDATE artist_profiles SET username = ?, display_name = ?, bio = ?, updated_at = unixepoch() WHERE wallet = ?`. BUT for the username update, use INSERT ON CONFLICT pattern. Actually for UPDATE, the race condition is: two wallets trying to claim the same username simultaneously. The UNIQUE constraint on username will cause the UPDATE to fail with a constraint error if another wallet claimed it between our check and our update. Wrap in try/catch, check for UNIQUE constraint error, return 400 `USERNAME_TAKEN`.
   - If NOT EXISTS: This is a CREATE. Use: `INSERT INTO artist_profiles (wallet, username, display_name, bio, created_at, updated_at) VALUES (?, ?, ?, ?, unixepoch(), unixepoch()) ON CONFLICT(username) DO NOTHING`. Check `result.meta.changes === 0` -- if 0, username was taken (race condition), return 400 `USERNAME_TAKEN`.

8. **Fetch and return the profile** -- Query: `SELECT * FROM artist_profiles WHERE wallet = ?`. Map DB row to `ArtistProfile` type (snake_case to camelCase). Return 200 with `ProfileResponse` shape.

**Error response format** -- Use `ProfileError` type from shared: `{ error: string, message: string, field?: string }`. Error codes: `INVALID_INPUT`, `USERNAME_TAKEN`, `USERNAME_RESERVED`, `INTERNAL_ERROR`. Match the SubmissionError pattern from submit.ts.

**Important implementation details:**
- Import `ProfileUpdateSchema`, `RESERVED_USERNAMES`, `ProfileError`, `ProfileResponse`, `ArtistProfile` from `@claw/shared`
- Import `verifyPayment` from `../middleware/x402`
- The Env type must include all bindings needed (DB, AUDIO_BUCKET, PLATFORM_WALLET, KV)
- Wrap entire handler in try/catch with INTERNAL_ERROR fallback (matching submit.ts pattern)
  </action>
  <verify>
TypeScript compilation: `npx tsc --noEmit -p api/tsconfig.json`. Manual test with wrangler dev:
1. `curl -X PUT http://localhost:8787/api/profile -H "Content-Type: application/json" -d '{"username": "ab", "displayName": "Test"}' ` should return 400 (username too short -- validation before payment)
2. `curl -X PUT http://localhost:8787/api/profile -H "Content-Type: application/json" -d '{"username": "admin", "displayName": "Test"}' ` should return 400 (reserved word -- validation before payment)
3. `curl -X PUT http://localhost:8787/api/profile -H "Content-Type: application/json" -d '{"username": "testartist", "displayName": "Test Artist"}' ` should return 402 (valid input, needs payment)
  </verify>
  <done>
PUT /api/profile creates profiles with x402 payment, validates username format and reserved words before payment, handles both creation and updates, and uses INSERT ON CONFLICT or UNIQUE constraint for race-safe username claims. Validation errors return 400 without payment. Valid requests without payment header return 402 with payment requirements.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement POST /api/avatar with x402 gating and R2 upload</name>
  <files>api/src/routes/avatar.ts</files>
  <action>
Replace the 501 stub in `api/src/routes/avatar.ts` with a full implementation for avatar upload.

**Env type** -- include DB, AUDIO_BUCKET, PLATFORM_WALLET bindings. Add IMAGES binding for CF Images if available (see note below).

**POST / handler** flow:

1. **Parse multipart body** -- `c.req.parseBody()`. Expect a field named `avatar` that is a File.

2. **Validate image file** -- Before payment:
   - Check `avatar` field exists and is a File instance. Return 400 `MISSING_AVATAR` if not.
   - Use `fileTypeFromBlob` (from `file-type` package, already a dependency) to validate magic number. Allowed types: `image/jpeg`, `image/png`, `image/webp`. Return 400 `INVALID_IMAGE_TYPE` if wrong type.
   - Check file size: max 2MB (2 * 1024 * 1024 bytes). Return 400 `IMAGE_TOO_LARGE` if over.

3. **Verify x402 payment** -- Same pattern as profile.ts. Requirements: `scheme: 'exact'`, `network: 'base'`, `maxAmountRequired: '10000'` (0.01 USDC), `asset: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'`, `resource: '/api/avatar'`, `description: 'Avatar upload fee'`, `payTo: c.env.PLATFORM_WALLET`.

4. **Check wallet has a profile** -- Query: `SELECT id FROM artist_profiles WHERE wallet = ?`. If no profile exists, return 400 `NO_PROFILE` with message "Create a profile before uploading an avatar". Profile must exist before avatar.

5. **Process and upload avatar** --

   **CF Images Binding approach (preferred):** If the `IMAGES` binding is available in `c.env`, use it:
   ```typescript
   const buffer = await avatarFile.arrayBuffer()
   const transformed = await c.env.IMAGES
     .input(buffer)
     .transform({ width: 256, height: 256, fit: 'cover' })
     .output({ format: 'image/webp', quality: 85 })
   ```
   Then upload the transformed result to R2.

   **Fallback approach (if IMAGES binding not available):** Upload the original image to R2 as-is (no resize). The frontend can handle display sizing via CSS. Use the original format detected by file-type. This is the safe fallback since CF Images Binding availability is an open question from research.

   **R2 upload:**
   - Key: `avatars/${walletAddress}.webp` (or original extension for fallback). Using wallet as key means each wallet has exactly one avatar, and re-uploads overwrite the previous one.
   - Upload with appropriate content type and cache headers: `cacheControl: 'public, max-age=31536000'`

6. **Update profile** -- `UPDATE artist_profiles SET avatar_url = ?, updated_at = unixepoch() WHERE wallet = ?`. Bind the R2 key (not a full URL -- the frontend/audio route will construct the URL).

7. **Return success** -- Return 200 with `{ avatarUrl: avatarKey }` where avatarKey is the R2 key path.

**Implementation notes:**
- Import `fileTypeFromBlob` from `file-type`
- Import `verifyPayment` from `../middleware/x402`
- Import `ProfileError` from `@claw/shared`
- For the IMAGES binding, add it to the Env type as optional: `IMAGES?: any` (the CF Images Binding type may not be in @cloudflare/workers-types yet). Check `if (c.env.IMAGES)` before using.
- Error responses use `ProfileError` shape for consistency
- Wrap in try/catch with INTERNAL_ERROR fallback
  </action>
  <verify>
TypeScript compilation: `npx tsc --noEmit -p api/tsconfig.json`. Manual test with wrangler dev:
1. `curl -X POST http://localhost:8787/api/avatar` should return 400 (missing avatar file -- validation before payment)
2. `curl -X POST http://localhost:8787/api/avatar -F "avatar=@test.txt"` should return 400 (invalid image type -- validation before payment)
3. A valid image upload without payment header should return 402
  </verify>
  <done>
POST /api/avatar accepts image uploads with x402 payment. Validates image type (magic number) and size before payment. Requires existing profile. Uploads to R2 with wallet-based key. Updates profile avatar_url. Uses CF Images Binding for resize if available, falls back to direct upload otherwise.
  </done>
</task>

</tasks>

<verification>
1. PUT /api/profile returns 400 for invalid username format (before payment)
2. PUT /api/profile returns 400 for reserved usernames (before payment)
3. PUT /api/profile returns 402 for valid input without payment
4. PUT /api/profile creates profile on valid payment
5. PUT /api/profile updates profile on subsequent valid payment from same wallet
6. POST /api/avatar returns 400 for missing/invalid image (before payment)
7. POST /api/avatar returns 402 for valid image without payment
8. POST /api/avatar uploads image and updates profile on valid payment
9. TypeScript compiles without errors
</verification>

<success_criteria>
- Profile creation works end-to-end with x402 payment flow
- Profile updates (including username changes) work with proper race condition handling
- Avatar upload validates, processes, stores in R2, and updates profile
- All validation errors return before payment settlement (API-05)
- Username collisions handled by INSERT ON CONFLICT or UNIQUE constraint (API-06)
- Error responses match existing claw.fm API patterns (ProfileError shape)
</success_criteria>

<output>
After completion, create `.planning/phases/07-schema-api/07-02-SUMMARY.md`
</output>
