---
phase: 05-payments-wallet
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - web/src/hooks/useUSDCTransfer.ts
  - web/src/hooks/useDownloadPurchase.ts
  - web/src/components/TipButtons.tsx
  - web/src/components/BuyButton.tsx
  - web/src/components/ConfettiCelebration.tsx
  - web/src/App.tsx
autonomous: false

must_haves:
  truths:
    - "Listener can tap a preset tip amount and two USDC transactions fire (95% artist, 5% platform)"
    - "Toast notifications show processing/success/error states during tip transactions"
    - "Confetti animation plays on successful tip"
    - "Listener can tap buy button and receive a download link after USDC transfer"
    - "Tip and buy buttons are disabled when wallet is not connected or USDC balance is insufficient"
    - "After successful tip, POST /api/tip is called to update rotation weight"
    - "All payment buttons are visible above the player bar in the main content area"
  artifacts:
    - path: "web/src/hooks/useUSDCTransfer.ts"
      provides: "Hook for sending USDC with 95/5 split"
      exports: ["useUSDCTransfer"]
    - path: "web/src/hooks/useDownloadPurchase.ts"
      provides: "Hook for buy flow (transfer + download link)"
      exports: ["useDownloadPurchase"]
    - path: "web/src/components/TipButtons.tsx"
      provides: "Preset tip amount buttons ($0.25, $1, $5)"
      exports: ["TipButtons"]
    - path: "web/src/components/BuyButton.tsx"
      provides: "Buy/download button ($2 USDC)"
      exports: ["BuyButton"]
    - path: "web/src/components/ConfettiCelebration.tsx"
      provides: "Canvas confetti animation overlay"
      exports: ["ConfettiCelebration"]
  key_links:
    - from: "web/src/hooks/useUSDCTransfer.ts"
      to: "wagmi useWriteContract"
      via: "writeContractAsync with ERC20 ABI"
      pattern: "writeContractAsync"
    - from: "web/src/hooks/useUSDCTransfer.ts"
      to: "web/src/lib/constants.ts"
      via: "USDC_ADDRESS, PLATFORM_WALLET, ERC20_TRANSFER_ABI"
      pattern: "USDC_ADDRESS.*PLATFORM_WALLET"
    - from: "web/src/components/TipButtons.tsx"
      to: "web/src/hooks/useUSDCTransfer.ts"
      via: "useUSDCTransfer hook call"
      pattern: "useUSDCTransfer"
    - from: "web/src/components/TipButtons.tsx"
      to: "/api/tip"
      via: "fetch POST after successful transfer"
      pattern: "fetch.*api/tip"
    - from: "web/src/components/BuyButton.tsx"
      to: "web/src/hooks/useDownloadPurchase.ts"
      via: "useDownloadPurchase hook call"
      pattern: "useDownloadPurchase"
    - from: "web/src/App.tsx"
      to: "web/src/components/TipButtons.tsx"
      via: "rendered in payment area above player bar"
      pattern: "TipButtons"
---

<objective>
Build the complete tip and buy/download frontend flows: USDC transfer hooks with 95/5 split, preset tip buttons with confetti celebration, buy button with download link delivery, toast notifications for all payment states. Wire everything into App.tsx above the player bar.

Purpose: This is the core monetization experience -- listeners can tip artists and buy tracks. Tips update rotation weight (QUEU-04), purchases deliver download links (PAY-07). Payment feedback keeps the listener informed (PAY-08).
Output: Working tip flow (PAY-01, PAY-04, PAY-05, PAY-06, PAY-08), buy flow (PAY-02, PAY-07), and tip weight update (QUEU-04).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-payments-wallet/05-CONTEXT.md
@.planning/phases/05-payments-wallet/05-RESEARCH.md
@.planning/phases/05-payments-wallet/05-01-SUMMARY.md
@.planning/phases/05-payments-wallet/05-02-SUMMARY.md

@web/src/App.tsx
@web/src/lib/constants.ts
@web/src/hooks/useNowPlaying.ts
@packages/shared/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: useUSDCTransfer hook + useDownloadPurchase hook + ConfettiCelebration</name>
  <files>
    web/src/hooks/useUSDCTransfer.ts
    web/src/hooks/useDownloadPurchase.ts
    web/src/components/ConfettiCelebration.tsx
  </files>
  <action>
Create `web/src/hooks/useUSDCTransfer.ts`:

```typescript
import { useWriteContract, useAccount } from 'wagmi'
import { parseUnits } from 'viem'
import { toast } from 'sonner'
import { USDC_ADDRESS, PLATFORM_WALLET, ERC20_TRANSFER_ABI, USDC_DECIMALS } from '../lib/constants'
```

Hook signature: `useUSDCTransfer()` returns `{ sendTransfer, isPending }`

`sendTransfer(artistWallet: string, usdcAmount: number)`:
- Calculate total amount: `parseUnits(usdcAmount.toString(), USDC_DECIMALS)`
- Calculate artist amount (95%): `const artistAmount = (total * 95n) / 100n`
- Calculate platform amount (5%): `const platformAmount = total - artistAmount` (ensures no rounding loss)
- IMPORTANT: artistAmount MUST be computed BEFORE platformAmount. The split order is: artistAmount first (95%), then platformAmount as remainder. This ensures the artist always gets the larger share and no dust is lost.
- Use `writeContractAsync` from wagmi's `useWriteContract()`
- Show toast: `toast.loading('Sending tip...')` before first transaction
- Execute artist transfer:
  ```
  writeContractAsync({
    address: USDC_ADDRESS as `0x${string}`,
    abi: ERC20_TRANSFER_ABI,
    functionName: 'transfer',
    args: [artistWallet as `0x${string}`, artistAmount]
  })
  ```
- On artist transfer success, execute platform transfer with same pattern
- On both success: dismiss loading toast, show `toast.success('Tip sent!')`, return { success: true, txHash: artistTxHash }
- On error at any point: dismiss loading toast, show `toast.error(err.message || 'Transaction failed')`, return { success: false, error: err.message }
- Track `isPending` state with useState (true between start and completion/error)

Important: Wrap everything in try/catch. If the first transaction succeeds but the second fails, still consider the tip "sent" (artist received their 95%). Show a warning toast: "Tip sent to artist. Platform fee pending." Return success: true.

Do NOT use `toast.promise()` -- we need more control over the messaging for two sequential transactions.

Create `web/src/hooks/useDownloadPurchase.ts`:

```typescript
import { useWriteContract } from 'wagmi'
import { parseUnits } from 'viem'
import { toast } from 'sonner'
import { USDC_ADDRESS, PLATFORM_WALLET, ERC20_TRANSFER_ABI, USDC_DECIMALS, BUY_PRICE_USDC } from '../lib/constants'
import type { DownloadResponse } from '@claw/shared'
```

Hook signature: `useDownloadPurchase()` returns `{ buyTrack, isPending, downloadUrl }`

`buyTrack(artistWallet: string, trackId: number)`:
- Same 95/5 split transfer logic as useUSDCTransfer, but with fixed BUY_PRICE_USDC amount
- After both transfers succeed, call `POST /api/downloads/${trackId}` to get download URL
- Parse response as DownloadResponse
- Store downloadUrl in state
- Show toast.success with a clickable link: `toast.success('Purchase complete!', { description: 'Download link ready', duration: 10000 })`
- Return { success: true, downloadUrl }
- On transfer error: same error handling as tip flow
- On download URL fetch error: show toast.error('Payment sent but download link failed. Contact support.') -- the money was sent, so don't hide that

Create `web/src/components/ConfettiCelebration.tsx`:
- Import ReactCanvasConfetti from 'react-canvas-confetti'
- Accept prop: `fire: boolean` (when true, trigger confetti burst)
- Use useCallback with ref pattern to get confetti instance
- When `fire` changes to true, call confetti with: particleCount: 80, spread: 60, origin: { y: 0.7 }, colors: ['#6366f1', '#8b5cf6', '#a855f7', '#ec4899']
- Canvas is fixed position, full viewport, pointer-events: none, z-index: 9999
- Use useEffect to watch `fire` prop and trigger

Note on react-canvas-confetti: The API may use a ref/callback pattern. Check the library's actual API. If it uses `onInit` callback that receives `{ confetti }`, store that function in a ref and call it when `fire` becomes true. If the library exports differently, adapt accordingly.
  </action>
  <verify>
`cd web && npx tsc --noEmit` passes. Hooks export correct signatures. ConfettiCelebration renders without errors.

Verify 95/5 split logic is correctly implemented:
- Grep useUSDCTransfer.ts for the split calculation: confirm `(total * 95n) / 100n` or equivalent `95n) / 100n` pattern exists
- Confirm `artistAmount` is computed before `platformAmount` (artist gets 95%, platform gets remainder)
- Confirm both `artistAmount` and `platformAmount` variables are used in separate writeContractAsync calls
  </verify>
  <done>
useUSDCTransfer hook handles 95/5 USDC split (artistAmount = 95% computed first, platformAmount = remainder) with toast notifications and error recovery. useDownloadPurchase hook handles buy flow with download URL retrieval. ConfettiCelebration component triggers canvas confetti animation on prop change. All type-check cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: TipButtons + BuyButton components + App.tsx payment area wiring</name>
  <files>
    web/src/components/TipButtons.tsx
    web/src/components/BuyButton.tsx
    web/src/App.tsx
  </files>
  <action>
Create `web/src/components/TipButtons.tsx`:

Props: `{ artistWallet: string; trackId: number; disabled?: boolean; onTipSuccess?: () => void }`

- Import useUSDCTransfer, useAccount, useBalance from wagmi, TIP_AMOUNTS and USDC_ADDRESS from constants
- Import { parseUnits } from 'viem' for balance comparison
- Use useAccount() to check isConnected
- Use useBalance({ address, token: USDC_ADDRESS }) to get USDC balance
- Use useUSDCTransfer() hook
- Render a row of 3 buttons for TIP_AMOUNTS ($0.25, $1, $5):
  - Each button shows the dollar amount: "$0.25", "$1", "$5"
  - Disabled when: !isConnected, isPending, or balance < amount, or disabled prop is true
  - On click: call sendTransfer(artistWallet, amount)
  - On success (sendTransfer returns { success: true, txHash }), call POST /api/tip to update rotation weight. Implementation:
    ```typescript
    if (result.success && result.txHash) {
      await fetch('/api/tip', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ trackId, amount, txHash: result.txHash })
      })
      onTipSuccess?.()
    }
    ```
    Note: The fetch to /api/tip is fire-and-forget for the UI. If it fails, the USDC transfer already succeeded (the artist got paid). Log the error but do not show an error toast to the user. The rotation weight update is a backend optimization, not a user-facing concern.
  - During isPending: show a small spinner on the active button
- Styling: flex row, gap-2, buttons are rounded-full with bg-indigo-500 hover:bg-indigo-600 text-white px-4 py-2 text-sm font-medium. Disabled state: bg-gray-200 text-gray-400 cursor-not-allowed

Create `web/src/components/BuyButton.tsx`:

Props: `{ artistWallet: string; trackId: number; trackTitle: string; disabled?: boolean }`

- Import useDownloadPurchase, useAccount, useBalance
- Import BUY_PRICE_USDC, USDC_ADDRESS from constants
- Disabled when: !isConnected, isPending, or balance < BUY_PRICE_USDC, or disabled prop
- Show "Buy $2" when idle, spinner when pending, "Download Ready" with link when downloadUrl is set
- When downloadUrl is set, render an anchor tag `<a href={downloadUrl} download>` styled as a green button
- Styling: similar to tip buttons but with distinct color (emerald-500 for buy, indigo-500 for tips)
- The download URL should open in same tab (direct download via Content-Disposition: attachment from the API)

Update `web/src/App.tsx`:

Add the payment area between the track info and the player bar (in the main content area, NOT inside the player bar). Only show payment buttons when there is an active track (not in waiting or pre-play state).

Import TipButtons, BuyButton, ConfettiCelebration, and useState for confetti trigger.

Add state: `const [showConfetti, setShowConfetti] = useState(false)`

In the main content area, after the track info div and before the closing `</div>` of the non-waiting content section, add:

```tsx
{/* Payment area - only show when playing */}
{crossfade.isPlaying && crossfade.currentTrack && nowPlaying.track && (
  <div className="flex items-center gap-3 mt-4">
    <TipButtons
      artistWallet={nowPlaying.track.artistWallet}
      trackId={nowPlaying.track.id}
      onTipSuccess={() => {
        setShowConfetti(true)
        setTimeout(() => setShowConfetti(false), 3000)
      }}
    />
    <div className="w-px h-8 bg-gray-200" /> {/* Divider */}
    <BuyButton
      artistWallet={nowPlaying.track.artistWallet}
      trackId={nowPlaying.track.id}
      trackTitle={nowPlaying.track.title}
    />
  </div>
)}
```

Add ConfettiCelebration at the top level of the component (inside the root div, before the main):
```tsx
<ConfettiCelebration fire={showConfetti} />
```

Keep all existing App.tsx code intact. The payment area is an addition, not a replacement.
  </action>
  <verify>
`cd web && pnpm run build` succeeds. Dev server shows tip ($0.25, $1, $5) and buy ($2) buttons below track info when a track is playing. Buttons appear disabled when wallet is not connected.

Verify POST /api/tip wiring in TipButtons.tsx:
- Grep TipButtons.tsx for `fetch.*api/tip` to confirm the POST call is implemented after successful transfer
- Confirm the fetch body includes trackId, amount, and txHash
  </verify>
  <done>
TipButtons renders 3 preset amounts, fires USDC transfers with 95/5 split, calls POST /api/tip (with fetch) on success using { trackId, amount, txHash }, triggers confetti callback. BuyButton renders $2 buy option, shows download link on success. Both components disable when wallet not connected or insufficient balance. Payment area wired into App.tsx above player bar, visible only during active playback.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete payment flow: embedded wallet connection, USDC tipping with preset amounts ($0.25, $1, $5), track purchase ($2 USDC) with download link, 95/5 fee split, confetti celebration on tip, toast notifications for all states, tip weight rotation update.
  </what-built>
  <how-to-verify>
**Verifiable without USDC funds (do ALL of these):**

1. Start dev server: `cd web && pnpm run dev`
2. Open http://localhost:5173 in browser
3. Verify wallet connect button appears in header (top right)
4. Click "Connect Wallet" -- should trigger Coinbase Smart Wallet creation flow
5. Once connected, verify address and USDC balance (likely "0.00 USDC") are shown in header
6. When a track is playing, verify tip buttons ($0.25, $1, $5) and buy button ($2) appear below track info
7. With 0 USDC balance, verify tip and buy buttons are disabled/grayed out (insufficient balance guard)
8. Check browser console for any errors
9. Verify existing player functionality still works (play/pause, volume, visualizer, crossfade)
10. Inspect TipButtons.tsx source to confirm `fetch('/api/tip'...)` call exists after successful transfer

**Requires USDC on Base (nice-to-test, not blocking if no funds):**

11. If wallet has USDC: tap a tip button, verify toast shows "Sending tip...", then wallet popup, then "Tip sent!" with confetti
12. After successful tip, check Network tab for POST /api/tip request firing
13. Tap buy button, verify toast flow, then "Download Ready" link appears
14. Click download link and verify file downloads

Note: Items 1-10 validate all UI/UX, component wiring, and disabled states. Items 11-14 validate the on-chain transaction flow and require real USDC on Base.
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
1. `cd web && pnpm run build` succeeds with no errors
2. Tip buttons visible during playback, disabled when wallet not connected
3. Buy button visible during playback, shows download link after purchase
4. Toast notifications render for all payment states (loading, success, error)
5. Confetti animation fires on successful tip
6. POST /api/tip called after successful tip transfer (grep TipButtons.tsx for `fetch.*api/tip`)
7. POST /api/downloads/:trackId called after successful buy transfer
8. 95/5 split logic correct (grep useUSDCTransfer.ts for `95n) / 100n` and `artistAmount` before `platformAmount`)
9. Existing player functionality unaffected
</verification>

<success_criteria>
- PAY-01: Listener can tip from preset amounts ($0.25, $1, $5 USDC) -- TipButtons component
- PAY-02: Listener can buy/download current track ($2 USDC) -- BuyButton component
- PAY-03: Wallet created on first payment action (OnchainKit Smart Wallet with smartWalletOnly) -- from Plan 01
- PAY-04: Payments via USDC on Base -- useUSDCTransfer with writeContractAsync
- PAY-05: Platform 5% fee -- split logic in useUSDCTransfer (platformAmount = total - artistAmount)
- PAY-06: 95% reaches agent wallet -- split logic in useUSDCTransfer (artistAmount = (total * 95n) / 100n)
- PAY-07: Download via time-limited URL -- useDownloadPurchase + API from Plan 02
- PAY-08: Payment state visible -- Sonner toasts (processing, success, error with retry)
- QUEU-04: Tips increase rotation weight -- POST /api/tip via fetch after successful transfer
</success_criteria>

<output>
After completion, create `.planning/phases/05-payments-wallet/05-03-SUMMARY.md`
</output>
