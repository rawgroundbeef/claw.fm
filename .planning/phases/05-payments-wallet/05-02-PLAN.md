---
phase: 05-payments-wallet
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - api/package.json
  - api/wrangler.toml
  - api/src/routes/tip.ts
  - api/src/routes/downloads.ts
  - api/src/lib/presigned.ts
  - api/src/index.ts
  - packages/shared/src/index.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/tip with trackId and amount updates the track's tip_weight in D1"
    - "POST /api/downloads/:trackId returns a time-limited presigned R2 URL for the track audio file"
    - "Tip endpoint validates trackId exists before updating"
    - "Download endpoint validates trackId exists and returns 404 for missing tracks"
    - "Presigned URLs expire after 72 hours"
  artifacts:
    - path: "api/src/routes/tip.ts"
      provides: "POST /api/tip endpoint"
      exports: ["default"]
    - path: "api/src/routes/downloads.ts"
      provides: "POST /api/downloads/:trackId endpoint"
      exports: ["default"]
    - path: "api/src/lib/presigned.ts"
      provides: "Presigned URL generation for R2"
      exports: ["generateDownloadUrl"]
    - path: "packages/shared/src/index.ts"
      provides: "TipRequest, TipResponse, DownloadResponse types"
      contains: "TipRequest"
  key_links:
    - from: "api/src/routes/tip.ts"
      to: "D1 tracks table"
      via: "UPDATE tracks SET tip_weight"
      pattern: "UPDATE tracks SET tip_weight"
    - from: "api/src/routes/downloads.ts"
      to: "api/src/lib/presigned.ts"
      via: "generateDownloadUrl call"
      pattern: "generateDownloadUrl"
    - from: "api/src/index.ts"
      to: "api/src/routes/tip.ts"
      via: "app.route('/api/tip', tipRoute)"
      pattern: "route.*tip"
---

<objective>
Create backend API endpoints for tipping (updates tip_weight in D1) and track download (generates time-limited presigned R2 URLs). These endpoints serve the frontend payment flows built in Plan 03.

Purpose: The tip endpoint connects listener payments to queue rotation weight (QUEU-04). The download endpoint enables purchased track delivery via secure, expiring URLs (PAY-07).
Output: Two new API routes mounted and functional, shared types updated.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-payments-wallet/05-CONTEXT.md
@.planning/phases/05-payments-wallet/05-RESEARCH.md

@api/src/index.ts
@api/src/routes/submit.ts
@api/wrangler.toml
@api/package.json
@packages/shared/src/index.ts
@api/src/lib/rotation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Shared types + POST /api/tip endpoint</name>
  <files>
    packages/shared/src/index.ts
    api/src/routes/tip.ts
  </files>
  <action>
Add shared types to `packages/shared/src/index.ts` (append, do not remove existing types):

```typescript
// Payment types
export interface TipRequest {
  trackId: number
  amount: number      // USDC amount (e.g. 0.25, 1, 5)
  txHash: string      // Transaction hash for artist transfer (for verification/logging)
}

export interface TipResponse {
  success: boolean
  newTipWeight: number
}

export interface DownloadResponse {
  downloadUrl: string
  expiresAt: number    // UNIX ms when URL expires
}
```

Create `api/src/routes/tip.ts`:
- Export a Hono router (same pattern as existing routes like genres.ts and queue.ts)
- POST handler accepts JSON body matching TipRequest
- Validate: trackId is a positive integer, amount is one of [0.25, 1, 5], txHash is a string starting with '0x'
- Return 400 with error message for invalid input
- Look up track in D1: `SELECT id, tip_weight FROM tracks WHERE id = ?`
- Return 404 if track not found
- Convert USDC amount to tip_weight increment: `amount * 1e18` (so $1 USDC = 1e18 wei-equivalent units). This means $0.25 = 2.5e17, $1 = 1e18, $5 = 5e18. Combined with the existing formula `1 + (tip_weight / 1e17)`, a $1 tip gives 11x boost, which is intentionally generous to reward tipping.

  Wait -- re-read the existing formula: `1 + (tip_weight / 1e17)` where 0.1 ETH (1e17) = 2x. The tip_weight is stored as a raw number in D1. The CONTEXT says tips are in USDC, not ETH. We need to decide on a conversion factor.

  Use this approach: Store tip_weight as cumulative USDC cents (amount * 100). A $1 tip adds 100 to tip_weight. Then the rotation formula `1 + (tip_weight / 1e17)` will give very small boosts per tip, which is fine -- tips accumulate over time.

  Actually, re-reading the rotation formula more carefully: tip_weight is already seeded at 0 for all tracks and the formula is `1 + (tip_weight / 1e17)`. If we store in cents, $1 = 100, and 100/1e17 is negligible. That defeats the purpose.

  Better approach: Store tip_weight as raw USDC amount * 1e6 (matching USDC's 6 decimal precision). So $1 = 1000000. Then 1000000 / 1e17 = 0.00001x boost. Still negligible.

  The existing system was designed for ETH-denominated tip_weight (0.1 ETH = 1e17 wei = 2x boost). We need to recalibrate for USDC.

  **Simplest fix:** Change the increment to use a scaling factor that makes USDC tips meaningful. Since the CONTEXT says tips should increase rotation weight noticeably, use: `increment = amount * 1e17`. This means:
  - $0.25 tip: 0.25 * 1e17 = 2.5e16 -> boost = 1 + (2.5e16 / 1e17) = 1.25x
  - $1 tip: 1e17 -> boost = 1 + 1 = 2x
  - $5 tip: 5e17 -> boost = 1 + 5 = 6x
  - Cumulative $10 in tips: 10e17 -> boost = 1 + 10 = 11x

  This makes tips meaningful and matches the original formula's intent.

- Update D1: `UPDATE tracks SET tip_weight = tip_weight + ? WHERE id = ?` with increment = `amount * 1e17`
- Fetch updated tip_weight: `SELECT tip_weight FROM tracks WHERE id = ?`
- Return 200 with TipResponse { success: true, newTipWeight }
- Invalidate KV cache: `c.env.KV.delete('now-playing')` (rotation weights changed)

Bindings type: Use same Bindings pattern from index.ts (DB, KV, etc.)
  </action>
  <verify>
`cd api && npx tsc --noEmit` passes. Tip route handles validation, updates D1, returns response.
  </verify>
  <done>
POST /api/tip accepts {trackId, amount, txHash}, validates input, updates tip_weight in D1 by amount * 1e17, invalidates KV cache, returns new tip_weight. Shared TipRequest/TipResponse/DownloadResponse types defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Presigned URL utility + POST /api/downloads/:trackId + route wiring</name>
  <files>
    api/src/lib/presigned.ts
    api/src/routes/downloads.ts
    api/src/index.ts
    api/wrangler.toml
    api/package.json
  </files>
  <action>
**Important Cloudflare Workers constraint:** The `@aws-sdk/client-s3` and `@aws-sdk/s3-request-presigner` packages are heavy Node.js packages that may NOT work in Cloudflare Workers runtime. Instead, use R2's native binding to generate presigned URLs.

Check if R2 bindings support presigned URLs directly. If they do (via `AUDIO_BUCKET.createSignedUrl()` or similar), use that. If not, use the Cloudflare Workers approach:

**Option A (preferred): Generate a signed URL using a simple HMAC approach:**
- Create a download token: `crypto.subtle.sign('HMAC', key, data)` where data = `trackId:expiresAt`
- Return `/api/downloads/:trackId/file?token=TOKEN&expires=TIMESTAMP`
- The file-serving endpoint verifies the token and streams from R2

**Option B: Use S3-compatible presigned URLs with AWS SDK (if Workers-compatible):**
Install in api package:
```bash
cd api && pnpm add @aws-sdk/client-s3 @aws-sdk/s3-request-presigner
```

Actually, for Cloudflare Workers, the simplest proven approach is Option A. Create a self-verifying signed URL system:

Create `api/src/lib/presigned.ts`:
```typescript
// Generate HMAC-signed download URL
// Token = HMAC-SHA256(secret, trackKey:expiresAt)
export async function generateDownloadToken(
  trackKey: string,
  expiresAt: number,
  secret: string
): Promise<string> {
  const encoder = new TextEncoder()
  const key = await crypto.subtle.importKey(
    'raw',
    encoder.encode(secret),
    { name: 'HMAC', hash: 'SHA-256' },
    false,
    ['sign']
  )
  const data = encoder.encode(`${trackKey}:${expiresAt}`)
  const signature = await crypto.subtle.sign('HMAC', key, data)
  return btoa(String.fromCharCode(...new Uint8Array(signature)))
    .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '') // URL-safe base64
}

export async function verifyDownloadToken(
  trackKey: string,
  expiresAt: number,
  token: string,
  secret: string
): Promise<boolean> {
  const expected = await generateDownloadToken(trackKey, expiresAt, secret)
  return token === expected
}
```

Create `api/src/routes/downloads.ts`:
Two endpoints on a Hono sub-router:

**POST /api/downloads/:trackId** (request download link):
- Look up track in D1: `SELECT id, file_url FROM tracks WHERE id = ?`
- Return 404 if track not found
- Extract the R2 key from file_url (strip the base URL prefix, get just the object key)
- Calculate expiresAt = Date.now() + (72 * 60 * 60 * 1000) (72 hours)
- Generate download token using HMAC with DOWNLOAD_SECRET env var
- Return DownloadResponse with downloadUrl = `/api/downloads/${trackId}/file?token=TOKEN&expires=TIMESTAMP`
- The URL is relative -- the frontend will resolve it against the API base

**GET /api/downloads/:trackId/file** (serve the file):
- Read `token` and `expires` from query params
- Verify token using verifyDownloadToken
- Check if current time < expires (not expired)
- Return 403 if invalid token or expired
- Look up track in D1 to get file_url
- Extract R2 key from file_url
- Fetch from R2: `c.env.AUDIO_BUCKET.get(r2Key)`
- Return 404 if R2 object not found
- Stream the file with Content-Type: audio/mpeg and Content-Disposition: attachment; filename="track-title.mp3"

Update `api/wrangler.toml`:
- Add `DOWNLOAD_SECRET = "dev-download-secret-change-in-production"` under [vars]

Update `api/src/index.ts`:
- Import tipRoute from './routes/tip'
- Import downloadsRoute from './routes/downloads'
- Mount: `app.route('/api/tip', tipRoute)`
- Mount: `app.route('/api/downloads', downloadsRoute)`
- Add DOWNLOAD_SECRET to Bindings type

Do NOT install @aws-sdk packages. The HMAC approach works natively in Workers with zero dependencies.
  </action>
  <verify>
`cd api && npx tsc --noEmit` passes. Routes are mounted in index.ts. wrangler.toml has DOWNLOAD_SECRET var.
  </verify>
  <done>
POST /api/downloads/:trackId generates HMAC-signed download URL with 72-hour expiry. GET /api/downloads/:trackId/file verifies token, streams file from R2 with download headers. POST /api/tip and both download routes mounted in index.ts. No external dependencies added (uses Web Crypto API natively).
  </done>
</task>

</tasks>

<verification>
1. `cd api && npx tsc --noEmit` passes with no errors
2. `packages/shared/src/index.ts` exports TipRequest, TipResponse, DownloadResponse
3. api/src/index.ts mounts /api/tip and /api/downloads routes
4. api/wrangler.toml has DOWNLOAD_SECRET in [vars]
5. Tip route updates tip_weight with correct scaling (amount * 1e17)
6. Download route generates HMAC-signed URLs with 72-hour expiry
</verification>

<success_criteria>
- POST /api/tip validates input, updates D1 tip_weight, invalidates KV cache
- POST /api/downloads/:trackId generates secure, time-limited download URLs
- GET /api/downloads/:trackId/file verifies token and streams from R2
- No new npm dependencies in API package (uses native Web Crypto)
- All shared types defined and importable from @claw/shared
- TypeScript compilation succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/05-payments-wallet/05-02-SUMMARY.md`
</output>
