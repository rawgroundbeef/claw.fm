---
phase: 02-submission-pipeline
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - api/src/routes/submit.ts
  - api/src/index.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/submit with valid MP3, title, genre, and x402 payment returns 200 with trackId, trackUrl, and queuePosition"
    - "POST /api/submit without payment header returns 402 with x402 payment requirements"
    - "POST /api/submit with invalid file type returns 400 with INVALID_AUDIO_TYPE error"
    - "POST /api/submit with oversized file returns 400 with FILE_TOO_LARGE error"
    - "POST /api/submit with duplicate audio hash from same wallet returns 400 with DUPLICATE_SUBMISSION error"
    - "Audio file is stored in R2 at tracks/{trackId}.mp3 with correct Content-Type"
    - "Track metadata is persisted in D1 with all fields (title, genre, wallet, duration, file_url, cover_url, file_hash)"
    - "Cover art uploads to R2 and URL stored in D1; identicon used as fallback when no image provided"
  artifacts:
    - path: "api/src/routes/submit.ts"
      provides: "POST /api/submit endpoint wiring validation, payment, storage, and persistence"
      min_lines: 80
    - path: "api/src/index.ts"
      provides: "Updated Hono app mounting submit route alongside health and genres"
      contains: "submitRoute"
  key_links:
    - from: "api/src/routes/submit.ts"
      to: "api/src/middleware/validation.ts"
      via: "validateSubmission call before payment check"
      pattern: "validateSubmission"
    - from: "api/src/routes/submit.ts"
      to: "api/src/middleware/x402.ts"
      via: "verifyPayment call after validation passes"
      pattern: "verifyPayment"
    - from: "api/src/routes/submit.ts"
      to: "api/src/lib/hash.ts"
      via: "hashFile for duplicate detection before storage"
      pattern: "hashFile"
    - from: "api/src/routes/submit.ts"
      to: "api/src/lib/identicon.ts"
      via: "generateIdenticon when no cover art provided"
      pattern: "generateIdenticon"
    - from: "api/src/routes/submit.ts"
      to: "api/src/lib/image.ts"
      via: "processAndUploadCoverArt when cover art provided"
      pattern: "processAndUploadCoverArt"
    - from: "api/src/routes/submit.ts"
      to: "c.env.AUDIO_BUCKET"
      via: "R2 put for audio file storage"
      pattern: "AUDIO_BUCKET\\.put"
    - from: "api/src/routes/submit.ts"
      to: "c.env.DB"
      via: "D1 insert for track metadata persistence"
      pattern: "DB\\.prepare.*INSERT"
---

<objective>
Build the POST /api/submit endpoint that orchestrates the full submission flow: parse multipart form, validate inputs, verify x402 payment, hash for duplicates, store audio in R2, process cover art (or generate identicon), persist metadata in D1, and return track info with queue position.

Purpose: This is the core submission endpoint -- the single API call an AI agent makes to get a track on claw.fm. It wires together all the validation, payment, and storage modules built in Plans 01 and 02 into one coherent flow.

Output: Working POST /api/submit endpoint mounted in the Hono app
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-submission-pipeline/02-CONTEXT.md
@.planning/phases/02-submission-pipeline/02-RESEARCH.md

# Prior plan outputs (must exist before this plan runs)
@.planning/phases/02-submission-pipeline/02-01-SUMMARY.md
@.planning/phases/02-submission-pipeline/02-02-SUMMARY.md

# Files this plan will read/modify
@api/src/index.ts
@packages/shared/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create POST /api/submit endpoint</name>
  <files>
    api/src/routes/submit.ts
  </files>
  <action>
    Create `api/src/routes/submit.ts` implementing the full submission flow.

    The Hono route handler for POST `/` (mounted at /api/submit in index.ts) follows this exact sequence:

    **Step 1: Parse multipart body**
    - Use `c.req.parseBody()` to get form fields
    - Extract: audio (File), title (string), genre (string), description (string, optional), tags (string, optional), image (File, optional)

    **Step 2: Validate all inputs (BEFORE payment)**
    - Call `validateSubmission(body)` from `../middleware/validation`
    - If invalid, return 400 with the structured error: `{ error: errorCode, message: msg, field: fieldName }`
    - This ensures agents never pay for a submission that would be rejected

    **Step 3: Hash audio file for duplicate detection**
    - Call `hashFile(audioFile)` from `../lib/hash`
    - Query D1: `SELECT id FROM tracks WHERE file_hash = ? AND wallet = ?`
    - But we don't have wallet yet (comes from payment). So hash the file now, but duplicate check happens AFTER payment verification in Step 5.
    - IMPORTANT: After hashing, the file stream is consumed. We need the file data again for R2 upload. Solutions:
      a. Read the file into an ArrayBuffer first (for files under ~100MB this is fine given Workers 128MB limit and our 50MB max)
      b. Use this ArrayBuffer for hashing (crypto.subtle.digest), duration extraction, and R2 upload
      Actually, for our 50MB max file size, reading into ArrayBuffer is acceptable. The DigestStream approach is still preferred but we need to re-read the file. Since Hono's parseBody gives us a File object, we can call `.arrayBuffer()` once and reuse it.

    **Step 4: Verify x402 payment**
    - Call `verifyPayment(c)` from `../middleware/x402`
    - If no payment or invalid payment, return the 402 response from the verifier
    - On success, extract `walletAddress` from the result

    **Step 5: Check for duplicates (now we have wallet)**
    - Query D1: `SELECT id FROM tracks WHERE file_hash = ? AND wallet = ?` binding (fileHash, walletAddress)
    - If exists, return 400: `{ error: "DUPLICATE_SUBMISSION", message: "This audio file has already been submitted from your wallet", field: "audio" }`

    **Step 6: Upload audio to R2**
    - Generate track key: `tracks/{timestamp}-{random}.mp3` (use crypto.randomUUID() for uniqueness)
    - Upload to R2 AUDIO_BUCKET: `bucket.put(key, audioArrayBuffer, { httpMetadata: { contentType: 'audio/mpeg', cacheControl: 'public, max-age=31536000' } })`
    - Construct file URL: the R2 key (full URL constructed with bucket domain later)

    **Step 7: Handle cover art**
    - If image file provided in submission:
      - Call `processAndUploadCoverArt(imageFile, trackId, c.env.AUDIO_BUCKET)`
      - But we don't have trackId yet (it comes from D1 INSERT). Use the same UUID/key prefix used for the audio file.
      - Store the returned R2 key as cover_url
    - If no image:
      - Call `generateIdenticon(walletAddress)` to get a data URL
      - Store the data URL as cover_url (small enough for D1 text field)

    **Step 8: Persist metadata in D1**
    - INSERT INTO tracks (title, genre, description, tags, wallet, artist_name, duration, file_url, file_hash, cover_url, created_at)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, unixepoch())
    - `tags` stored as JSON string: `JSON.stringify(parsedTags)` or null
    - `artist_name`: For MVP, use wallet address as artist name. Can be updated later.
    - Get the inserted row ID from D1 result: `result.meta.last_row_id`

    **Step 9: Calculate queue position**
    - Query D1: `SELECT COUNT(*) as count FROM tracks` to get total track count
    - Queue position = count (this track is last in queue, approximately)

    **Step 10: Return success response**
    - Return 200 with SubmitResponse shape:
      ```json
      {
        "trackId": 42,
        "trackUrl": "tracks/{key}.mp3",
        "queuePosition": 15,
        "title": "My Track",
        "genre": "electronic",
        "duration": 180000,
        "coverUrl": "covers/{key}.jpg"
      }
      ```

    Type the Hono app with proper Bindings:
    ```typescript
    type Env = {
      Bindings: {
        DB: D1Database
        AUDIO_BUCKET: R2Bucket
        PLATFORM_WALLET: string
      }
    }
    ```
  </action>
  <verify>
    - `cd api && pnpm exec tsc --noEmit` compiles without errors
    - Route file imports all required modules (validation, x402, hash, identicon, image)
    - Flow order is: parse -> validate -> hash -> payment -> duplicate check -> upload -> cover art -> persist -> respond
  </verify>
  <done>
    POST /api/submit endpoint implements the full validate-first-then-charge submission flow. All library modules from Plan 02 are wired in. The endpoint handles the complete lifecycle from multipart parsing to D1 persistence.
  </done>
</task>

<task type="auto">
  <name>Task 2: Mount submit route and end-to-end verification</name>
  <files>
    api/src/index.ts
  </files>
  <action>
    1. Update `api/src/index.ts`:
       - Import submit route from `./routes/submit`
       - Mount at `/api/submit`: `app.route('/api/submit', submitRoute)`
       - Update Bindings type to include PLATFORM_WALLET: `PLATFORM_WALLET: string`
       - Keep existing /health endpoint and genres route mount

    2. Add PLATFORM_WALLET to wrangler.toml as a placeholder env var (or [vars] section):
       ```toml
       [vars]
       PLATFORM_WALLET = "0x0000000000000000000000000000000000000000"
       ```
       This is a dev placeholder. Real wallet configured via `wrangler secret put PLATFORM_WALLET` for production.

    3. Start wrangler dev and run manual smoke tests:

       a. Test validation rejection (no payment needed for validation errors):
       ```bash
       # Missing audio file
       curl -X POST http://localhost:8787/api/submit -F "title=Test" -F "genre=electronic"
       # Expected: 400 with MISSING_AUDIO error

       # Wrong file type (send a text file as audio)
       echo "not an mp3" > /tmp/fake.txt
       curl -X POST http://localhost:8787/api/submit -F "audio=@/tmp/fake.txt" -F "title=Test" -F "genre=electronic"
       # Expected: 400 with INVALID_AUDIO_TYPE error

       # Invalid genre
       curl -X POST http://localhost:8787/api/submit -F "audio=@/tmp/fake.txt" -F "title=Test" -F "genre=invalid-genre"
       # Expected: 400 with INVALID_GENRE error
       ```

       b. Test payment gate (valid file but no payment):
       To test this, we need a real MP3 file. Create a minimal valid MP3 for testing:
       ```bash
       # If ffmpeg is available:
       ffmpeg -f lavfi -i "sine=frequency=440:duration=5" -codec:a libmp3lame -b:a 128k /tmp/test-track.mp3 2>/dev/null

       # If no ffmpeg, use a minimal MP3 header (ID3 + MPEG frame sync):
       # The validation should still work with file-type checking magic bytes
       ```

       Then test:
       ```bash
       curl -X POST http://localhost:8787/api/submit \
         -F "audio=@/tmp/test-track.mp3" \
         -F "title=Test Track" \
         -F "genre=electronic"
       # Expected: 402 with PAYMENT_REQUIRED and X-PAYMENT-REQUIRED header
       ```

       c. The full flow with actual x402 payment cannot be tested locally (requires real USDC payment). The 402 response with payment requirements is the correct terminal state for local testing.

    4. Verify the API starts without errors and handles the submission flow up to the payment gate.
  </action>
  <verify>
    - `cd api && pnpm exec wrangler dev --local` starts without errors
    - `curl http://localhost:8787/health` still returns 200
    - `curl http://localhost:8787/api/genres` still returns genre list
    - POST /api/submit without audio returns 400 with structured error
    - POST /api/submit with non-MP3 returns 400 with INVALID_AUDIO_TYPE
    - POST /api/submit with valid MP3 but no payment returns 402 with payment requirements
    - TypeScript compilation passes: `pnpm --filter claw-fm-api exec tsc --noEmit`
  </verify>
  <done>
    Submit route mounted at /api/submit. Validation errors return 400 with machine-readable error codes. Valid submissions without payment return 402 with x402 payment requirements. Full submission flow is wired end-to-end: validate -> hash -> payment -> duplicate check -> R2 upload -> cover art -> D1 persist -> response. The endpoint is ready for agents to submit tracks with x402 payments.
  </done>
</task>

</tasks>

<verification>
1. POST /api/submit rejects invalid submissions with structured 400 errors (MISSING_AUDIO, INVALID_AUDIO_TYPE, FILE_TOO_LARGE, MISSING_TITLE, MISSING_GENRE, INVALID_GENRE)
2. POST /api/submit with valid file but no payment returns 402 with x402 requirements header
3. All existing endpoints (/health, /api/genres) still work
4. TypeScript compiles cleanly
5. Submit route imports and calls all Plan 02 modules (validation, x402, hash, identicon, image)
6. D1 INSERT includes all required fields (title, genre, wallet, duration, file_url, file_hash, cover_url, etc.)
</verification>

<success_criteria>
- Agent submitting with missing/invalid audio gets 400 with machine-readable error code and field reference
- Agent submitting valid audio without payment gets 402 with x402 payment requirements in response headers
- Submission flow follows validate-first-then-charge pattern (validation before payment check)
- Audio stored in R2, metadata persisted in D1, cover art handled (upload or identicon fallback)
- Response includes trackId, trackUrl, and queuePosition
- All three API routes work: /health, /api/genres, /api/submit
</success_criteria>

<output>
After completion, create `.planning/phases/02-submission-pipeline/02-03-SUMMARY.md`
</output>
